{
    "degree_centrality": {
        "technical": "Degree centrality measures the fraction of nodes in the graph that a given node is connected to. For an undirected graph, the degree centrality of a node is calculated as the degree of the node (the number of edges connected to it) divided by the maximum possible degree in the graph, which is n-1 (where n is the total number of nodes). For directed graphs, separate in-degree and out-degree centralities can be calculated. In cases of graphs with self-loops or multigraphs, the degree centrality may exceed 1, as the maximum degree can surpass n-1. The function returns a dictionary where each node is mapped to its normalized degree centrality value.",
        "colloquial": "Measures how many direct connections each node has compared to the maximum possible. It shows which nodes have the most immediate neighbors in the network."
    },
    "closeness_centrality": {
        "technical": "Closeness centrality measures the reciprocal of the average shortest path distance from a node to all other reachable nodes in the graph. The closeness centrality of a node $u$ is calculated as $(n - 1)$ divided by the sum of the shortest path distances from all reachable nodes to $u$, where $n$ is the number of reachable nodes. In directed graphs, the distance is computed inward to $u$. If you need outward distance, you can reverse the graph using G.reverse(). Higher closeness centrality values indicate that a node is more central, as it has shorter average distances to other nodes. For graphs with multiple connected components, Wasserman and Faust proposed an improved formula that adjusts closeness by multiplying by the ratio of the number of reachable nodes $(n - 1)$ to the total number of nodes $(N - 1)$. This scaling ensures that nodes in smaller components receive lower closeness values. The formula becomes $(n - 1) / (N - 1)$ times the original closeness value. The function takes an optional edge attribute key to use as the edge distance in shortest path calculations. If this attribute is not provided, all edges are assumed to have a distance of 1. The parameter wf_improved applies the Wasserman and Faust scaling. The function returns a dictionary where each node is associated with its closeness centrality value.",
        "colloquial": "Indicates how quickly a node can reach all other nodes in the network. Nodes with high closeness centrality can spread information efficiently due to shorter average distances to others."
    },
    "pagerank": {
        "technical": "PageRank centrality calculates the importance of each node in a directed graph based on the structure of its incoming links. The centrality of a node is determined by the centrality of its neighbors, distributing centrality proportional to the incoming links a node receives. The formula incorporates a damping factor (commonly set to 0.85) that controls the probability that a random walker follows a link to another node versus jumping to any node in the network. The algorithm ensures that even nodes with few incoming links can still have non-zero centrality by allowing for random jumps. The PageRank centrality of a node is computed iteratively, where each node's score is updated based on the scores of the nodes linking to it. The algorithm converges once the change in scores falls below a given tolerance or the maximum number of iterations is reached. Additionally, the PageRank can incorporate a personalization vector that biases the random jumps toward a specific set of nodes, making it adaptable for scenarios like personalized ranking. PageRank is sensitive to the presence of 'dangling' nodes (nodes without outgoing links), which can be handled by redistributing their score evenly or according to a predefined distribution. The result is a ranking of nodes based on their relative importance, with higher values indicating greater centrality.",
        "colloquial": "Identifies important nodes by considering not just the number of connections, but the quality of those connections. A node linked to by other important nodes will have a higher rank, similar to how popular webpages are ranked."
    },
    "eigenvector_centrality_numpy": {
        "technical": "Eigenvector Centrality calculates the centrality of each node based on the centrality of its neighbors. It utilizes a left eigenvector associated with the maximum modulus eigenvalue that is positive. The eigenvector centrality for a node is determined by summing the centrality values of its predecessors. The algorithm uses power iteration with specified parameters like maximum iterations and error tolerance to converge to the dominant eigenvector. The resulting dictionary contains nodes with their corresponding eigenvector centrality values, ensuring that the vector has a unit Euclidean norm and non-negative values.",
        "colloquial": "Measures a node's influence based on how influential its neighbors are. Nodes connected to other important nodes get higher scores."
    },
    "load_centrality": {
        "technical": "The load centrality of a node is the fraction of all shortest paths that pass through that node. The function takes parameters such as the graph G, a boolean for normalization, an optional weight attribute for considering edge weights, and a cutoff parameter for limiting path lengths. It returns a dictionary with nodes as keys and their corresponding centrality values. Load centrality is distinct from betweenness centrality and was initially proposed by a specific source.",
        "colloquial": "Shows how much 'load' or traffic a node carries based on the number of shortest paths passing through it. It highlights nodes that serve as key transit points."
    },
    "harmonic_centrality": {
        "technical": "The harmonic centrality of a specific node $u$ is the sum of the reciprocal of the shortest path distances from all other nodes to node $u$. The formula for harmonic centrality is $C(u) = \\sum_{v \\neq u} \\frac{1}{d(v, u)}$, where $d(v, u)$ represents the shortest-path distance between nodes $v$ and $u$. If specified, harmonic centrality values can be calculated based on the reciprocals of the shortest path distances from a subset of nodes (sources) to node $u$. Higher values of harmonic centrality indicate higher centrality of a node. The function takes a graph G, a container of nodes nbunch for which centrality values are calculated, a container of source nodes for reciprocal distance computation, and an optional edge attribute key for distance calculation. The function returns a dictionary with nodes as keys and their harmonic centrality values as the corresponding values. If the 'distance' keyword is provided, Dijkstra's algorithm is used with the specified edge attribute as the edge weight for shortest path length computation.",
        "colloquial": "Assesses how close a node is to all others by giving more weight to nearby nodes. It adds up the inverses of the shortest distances from other nodes, highlighting nodes that are centrally located."
    },
    "shortest_path": {
        "technical": "A shortest path algorithm calculates the path between nodes in a graph such that the total weight of the edges traversed is minimized. For unweighted graphs, the shortest path is the one with the fewest edges, while in weighted graphs, the path minimizes the sum of the edge weights. The algorithm allows for specifying a source node, a target node, and an optional edge weight attribute to account for weighted edges. If no edge weights are specified, all edges are treated as having equal weight. The function can return a list representing the sequence of nodes in the shortest path between the source and target, or a dictionary of shortest paths for all node pairs if no specific target is provided. Different algorithms can be used depending on the graph type and edge attributes, such as Dijkstra's algorithm for weighted graphs or BFS for unweighted graphs.",
        "colloquial": "Finds the quickest route between two points in a network. You can specify where to start and end, and choose how the paths are calculated. It returns the shortest path or paths in the graph."
    },
    "find_cliques_recursive": {
        "technical": "The recursive clique finding algorithm returns an iterator over all maximal cliques in a graph. A maximal clique for a node is the largest complete subgraph containing that node. The largest maximal clique is known as the maximum clique. It is a recursive implementation that may face recursion depth issues. It accepts a list of nodes and only returns maximal cliques containing all of these nodes. This can speed up the process if specific cliques are of interest. The algorithm avoids storing all cliques in memory by keeping only current candidate node lists during the search. The implementation is based on the Bron-Kerbosch algorithm with adaptations by Tomita, Tanaka, and Takahashi.",
        "colloquial": "Identifies all the largest groups where every member is directly connected to every other member. These groups are called cliques."
    },
    "average_clustering": {
        "technical": "The clustering coefficient is the average of local clustering coefficients for all nodes in the graph. It is calculated as the sum of local clustering coefficients divided by the number of nodes. The function allows for specifying a subset of nodes to compute the average clustering for and also considers edge weights if provided. Additionally, there is an option to exclude nodes with zero clustering values from the average calculation. The function returns the average clustering coefficient as a float value. It is noted that self-loops are not considered in the computation.",
        "colloquial": "Calculates how tightly knit the network is by averaging how clustered each node's neighborhood is. It gives a sense of the overall tendency of nodes to form close groups."
    },
    "transitivity": {
        "technical": "Graph transitivity is the fraction of all possible triangles present in the graph. This is done by identifying the number of 'triads' (two edges with a shared vertex) and then using the formula: $T = 3 \\times (\\text{number of triangles}) / (\\text{number of triads})$. The function takes a graph G as a parameter and returns the transitivity as a float value. Self-loops are ignored in the calculations.",
        "colloquial": "Measures the likelihood that two friends of a node are also friends with each other, indicating the overall clustering tendency of the network."
    },
    "effective_graph_resistance": {
        "technical": "Effective graph resistance, also known as the Kirchhoff index, sums the resistance distance between every pair of nodes in the graph. If no weights are provided, a weight of 1 is assigned to all edges. The effective graph resistance is infinite for disconnected graphs. The function allows for specifying edge weights and inverting weights for proper resistance distance calculation. The result is the effective graph resistance value as a float. The function raises exceptions for directed graphs and graphs without nodes. The implementation ignores self-loops and contracts multi-edges into one with adjusted weights.",
        "colloquial": "Calculates a measure of how well connected the entire network is by summing up how difficult it is to travel between all pairs of nodes."
    },
    "degree_assortativity_coefficient": {
        "technical": "The degree assortativity coefficient of a graph measures the similarity of connections based on node degree. It takes a graph as input, along with optional parameters for directed graphs (source and target node degree types), edge weight attribute, and a list of nodes to compute assortativity for. It returns a float value representing the assortativity of the graph by degree. The calculation considers the joint probability distribution (mixing matrix) of node degrees.",
        "colloquial": "Determines whether nodes tend to connect to others that are similar in terms of how many connections they have. Positive values mean similar nodes connect, negative values mean they connect to different ones."
    },
    "average_degree_connectivity": {
        "technical": "The average degree connectivity of a graph is the average nearest neighbor degree of nodes with a specific degree. For weighted graphs, a similar measure can be obtained using the weighted average neighbor's degree, which considers the weights of the edges connecting nodes and the weighted degrees of the nodes. The function takes parameters such as the graph, source and target specifications for directed graphs, specific nodes to compute neighbor connectivity for, and an optional weight attribute for edges. The output is a dictionary where the keys represent the degree k and the values are the corresponding average connectivity values.",
        "colloquial": "Calculates the average degree of neighbors for nodes with a certain degree. It shows whether high-degree nodes are connected to other high-degree nodes or to low-degree ones."
    },
    "average_neighbor_degree": {
        "technical": "Average neighbor degree calculates the average degree of the neighbors of each node in a graph. In undirected graphs, the neighbors of a node are those directly connected to it by an edge. In directed graphs, the neighborhood can be defined based on incoming edges, outgoing edges, or both, depending on the directionality being considered. The average neighbor degree of a node is computed by summing the degrees of all its neighbors and dividing by the total number of neighbors. For weighted graphs, the calculation can be adjusted by considering edge weights, where the contribution of each neighbor's degree is scaled by the corresponding edge weight. The function takes parameters such as the type of graph (directed or undirected), the type of neighborhood (incoming, outgoing, or both), and an optional edge weight attribute. It returns a dictionary where each node is associated with the average degree of its neighbors.",
        "colloquial": "Shows the average number of connections that a node's neighbors have. It helps understand the connectivity pattern around each node."
    },
    "greedy_color": {
        "technical": "Greedy coloring refers to a class of algorithms that assign colors to the nodes of a graph one at a time, following a specific sequence dictated by a chosen strategy. The goal is to achieve a proper coloring, where no two adjacent nodes share the same color, while using as few colors as possible. Various strategies influence the order in which nodes are colored, impacting the efficiency of the coloring process. Common strategies include:\n- Largest First: Nodes are processed in decreasing order of their degrees (number of connections).\n- Random Sequential: Nodes are processed in a random order.\n- Smallest Last: Nodes are processed in an order obtained by repeatedly removing the node with the smallest degree.\n- Independent Set: Nodes are colored by identifying maximal independent sets iteratively.\n- Connected Sequential BFS: Nodes are processed in the order determined by a breadth-first search traversal.\n- Connected Sequential DFS: Nodes are processed in the order determined by a depth-first search traversal.\n- Saturation Largest First: Nodes are selected based on the highest saturation degree, which is the number of different colors to which the node is adjacent.\nWhile greedy coloring algorithms do not guarantee an optimal solution (i.e., the minimal number of colors equal to the graph's chromatic number), they often produce satisfactory results efficiently. An optional color interchange technique can be employed to potentially reduce the total number of colors used by reassigning colors among nodes under certain conditions.",
        "colloquial": "Assigns colors to nodes so that no two connected nodes share the same color, using as few colors as possible. Different strategies determine the coloring order."
    },
    "resource_allocation_index": {
        "technical": "The resource allocation index is a measure used in link prediction to quantify the likelihood of a link existing between two nodes based on their shared neighbors. For a pair of nodes $u$ and $v$, the index is calculated as: $RA(u, v) = \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{|\\Gamma(w)|}$ where $\\Gamma(u)$ denotes the set of neighbors of node $u$, and the summation runs over all common neighbors $w$ of $u$ and $v$. The idea is that a common neighbor $w$ contributes more to the resource allocation index if it has fewer connections, reflecting a higher influence on linking $u$ and $v$. This index assigns higher scores to node pairs that share low-degree common neighbors, suggesting a greater likelihood of a future or missing link between them.",
        "colloquial": "Calculates a score for pairs of nodes based on shared neighbors, where more shared neighbors increase the likelihood of a connection."
    },
    "betweenness_centrality": {
        "technical": "Betweenness centrality is a measure of the importance of a node within a network based on the number of shortest paths that pass through the node. Mathematically, the betweenness centrality $C_B(v)$ of a node $v$ is defined as: $C_B(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ where $\\sigma_{st}$ is the total number of shortest paths from node $s$ to node $t$, and $\\sigma_{st}(v)$ is the number of those paths that pass through $v$. The summation considers all pairs of distinct nodes $s$ and $t$ in the network. Nodes with high betweenness centrality act as critical connectors or bridges within the network, influencing the flow of information or resources. The measure can be normalized by dividing by the number of pairs of nodes not including $v$. Extensions of this concept include edge betweenness centrality and considerations for weighted or directed graphs.",
        "colloquial": "Measures how often a node appears on the shortest paths between other nodes. Nodes with high betweenness connect different parts of the network."
    },
    "diameter": {
        "technical": "The diameter of a graph is the greatest distance between any pair of nodes in the network. Formally, it is defined as: $\\text{diameter} = \\max_{u, v \\in V} d(u, v)$ where $V$ is the set of nodes and $d(u, v)$ is the shortest-path distance between nodes $u$ and $v$. The diameter provides a measure of the graph's overall extent and is sensitive to the presence of outliers or long paths. In disconnected graphs, the diameter is often considered infinite, or it can be defined separately for each connected component.",
        "colloquial": "Finds the greatest distance between any two nodes in the network."
    },
    "radius": {
        "technical": "The radius of a graph is the minimum eccentricity among all nodes in the network. The eccentricity $e(v)$ of a node $v$ is the greatest distance between $v$ and any other node in the graph: $e(v) = \\max_{u \\in V} d(u, v)$ Thus, the radius is computed as: $\\text{radius} = \\min_{v \\in V} e(v)$ The radius indicates the distance from the graph's most central point (or points) to its most peripheral points. Nodes with eccentricity equal to the radius are considered central nodes in the network.",
        "colloquial": "Identifies the minimum distance from a node to its farthest node, highlighting the most central point in the network."
    },
    "eccentricity": {
        "technical": "The eccentricity of a node in a graph is the greatest distance between that node and any other node. For a node $v$, the eccentricity $e(v)$ is defined as: $e(v) = \\max_{u \\in V} d(u, v)$ where $d(u, v)$ is the shortest-path distance between nodes $u$ and $v$, and $V$ is the set of all nodes in the graph. The eccentricity provides insight into how far a node is from the node farthest from it in the network. Nodes with the smallest eccentricity are centrally located, while those with the largest eccentricity are peripheral. Eccentricity is used in calculating other graph invariants such as diameter and radius.",
        "colloquial": "Shows how far a node is from the node that's farthest from it in the network."
    },
    "articulation_points": {
        "technical": "Articulation points, also known as cut vertices, are nodes in a graph whose removal increases the number of connected components. In other words, they are nodes that, if removed along with their incident edges, disconnect the graph. Identifying articulation points is crucial for understanding the vulnerability and resilience of networks. A node $v$ is an articulation point if and only if it satisfies one of the following conditions:\n- $v$ is the root of a depth-first search (DFS) tree and has at least two children.\n- $v$ is not the root of a DFS tree, and there exists a child $w$ of $v$ such that $\\text{low}[w] \\geq \\text{disc}[v]$.\nThe standard algorithm for finding articulation points involves performing a DFS traversal and computing discovery and lowpoint values for each node.",
        "colloquial": "Finds nodes that, if removed, would break the network into separate pieces."
    },
    "bridges": {
        "technical": "Bridges, or cut edges, are edges in a graph whose removal increases the number of connected components. An edge $e = (u, v)$ is a bridge if it does not belong to any cycle, meaning there is no alternative path connecting $u$ and $v$ that does not use $e$. Bridges are critical connections; their failure can disrupt communication between parts of the network. To identify bridges, one can use a depth-first search (DFS) to assign discovery times and low values to nodes, and determine for each edge whether it is a bridge based on these values. An edge $(u, v)$ is a bridge if the low value of $v$ is greater than the discovery time of $u$.",
        "colloquial": "Identifies connections that, if removed, would split the network into separate parts."
    },
    "average_shortest_path_length": {
        "technical": "The average shortest path length in a graph is the mean of the shortest path distances between all pairs of nodes. It is calculated as: $\\ell = \\frac{1}{|V|(|V| - 1)} \\sum_{u \\neq v} d(u, v)$ where $V$ is the set of nodes, and $d(u, v)$ is the shortest-path distance between nodes $u$ and $v$. This metric provides insight into the overall navigability of the network. A smaller average shortest path length indicates that information or resources can spread quickly across the network. The calculation assumes the graph is connected; for disconnected graphs, the average is often taken over all pairs in the largest connected component.",
        "colloquial": "Calculates the average distance between all pairs of nodes in the network."
    },
    "barycenter": {
        "technical": "The barycenter of a connected graph, also known as the graph center or median, is the set of nodes that minimize the sum of their distances to all other nodes in the graph. For a node $v$, the sum of distances $D(v)$ is calculated as: $D(v) = \\sum_{u \\in V} d(u, v)$ The barycenter consists of nodes for which $D(v)$ attains its minimum value. These nodes are considered the most central with respect to distance and are optimal choices for placing facilities or resources to minimize overall travel distance within the network.",
        "colloquial": "Finds the node or nodes that are, on average, closest to all other nodes in the network."
    },
    "current_flow_closeness_centrality": {
        "technical": "Current-flow closeness centrality, also known as information centrality, measures the closeness of a node based on effective resistance distances in the network. Unlike traditional closeness centrality, which considers shortest-path distances, this metric accounts for all possible paths between nodes, weighted by their resistance (or inverse conductance). For a node $v$, the current-flow closeness centrality $C_{CF}(v)$ is defined as: $C_{CF}(v) = \\frac{n - 1}{\\sum_{u \\neq v} r(u, v)}$ where $n$ is the total number of nodes, and $r(u, v)$ is the effective resistance between nodes $u$ and $v$. This measure reflects how easily information can spread from a node to all others, considering the network's connectivity.",
        "colloquial": "Measures how easily information flows from a node to all others, considering all possible paths like currents in an electrical circuit."
    },
    "all_pairs_lowest_common_ancestor": {
        "technical": "In the context of rooted trees or directed acyclic graphs (DAGs), the lowest common ancestor (LCA) of two nodes $u$ and $v$ is the deepest node that is an ancestor of both $u$ and $v$. The all-pairs lowest common ancestor problem involves finding the LCA for every pair of nodes in the graph. This can be efficiently solved using algorithms like Tarjan's offline LCA algorithm, which preprocesses the tree to answer LCA queries in near-linear time. The concept is fundamental in areas such as taxonomy, file systems, and computational biology, where hierarchical relationships are represented as trees.",
        "colloquial": "Finds the deepest shared ancestor for each pair of nodes in a tree-like structure."
    },
    "capacity_scaling": {
        "technical": "The capacity scaling algorithm is a method for solving the minimum-cost flow problem in a network with supplies, demands, capacities, and costs associated with edges. It operates by finding augmenting paths that can carry flow in units of decreasing capacity scales. The algorithm begins with a large scaling parameter $\\Delta$, typically the largest power of two less than or equal to the maximum capacity. It then repeatedly augments flow along paths with residual capacity at least $\\Delta$, reducing $\\Delta$ by half each time until it reaches one. At each scale, the algorithm uses shortest augmenting paths with respect to the cost per unit flow. The capacity scaling approach improves efficiency over the generic successive shortest augmenting path method, especially for networks with large capacities. It guarantees a polynomial-time solution and is applicable to networks with integer capacities and costs.",
        "colloquial": "Finds the cheapest way to send required amounts through a network from sources to destinations, considering capacities and costs."
    },
    "rich_club_coefficient": {
        "technical": "The rich-club coefficient quantifies the tendency of high-degree nodes (the 'rich' nodes) in a network to be more densely interconnected than expected by chance. For a degree threshold $k$, the rich-club coefficient $\\phi(k)$ is defined as: $\\phi(k) = \\frac{2 E_k}{N_k (N_k - 1)}$ where $N_k$ is the number of nodes with degree greater than $k$, and $E_k$ is the number of edges among those nodes. The numerator represents the actual number of edges between the rich nodes, while the denominator represents the maximum possible number of such edges. A rich-club coefficient greater than expected indicates the presence of a tightly interconnected core of high-degree nodes, which can have implications for network robustness and information flow.",
        "colloquial": "Measures how interconnected the most connected nodes are compared to how connected they could be, showing if high-degree nodes form tight groups."
    },
    "center": {
        "technical": "The center of a graph is the set of nodes with eccentricity equal to the graph's radius. The radius is the minimum eccentricity among all nodes, where the eccentricity $e(v)$ of a node $v$ is the greatest distance to any other node in the graph. Formally, the center $C$ is defined as: $C = \\{ v \\in V \\mid e(v) = \\text{radius} \\}$ Nodes in the center are the most central points in the network, minimizing the maximum distance to all other nodes. They are often considered optimal locations for services or facilities that need to be accessible to all parts of the network.",
        "colloquial": "Finds the most central nodes in the network, which are closest to all other nodes."
    },
    "jaccard_coefficient": {
        "technical": "The Jaccard coefficient is a measure of similarity between two sets, applied in network analysis to quantify the similarity between the neighbor sets of two nodes. For nodes $u$ and $v$, the Jaccard coefficient $J(u, v)$ is calculated as: $J(u, v) = \\frac{|\\Gamma(u) \\cap \\Gamma(v)|}{|\\Gamma(u) \\cup \\Gamma(v)|}$ where $\\Gamma(u)$ and $\\Gamma(v)$ are the sets of neighbors of nodes $u$ and $v$, respectively. The coefficient ranges from 0 to 1, where 0 indicates no shared neighbors and 1 indicates identical neighbor sets. It is commonly used in link prediction to estimate the likelihood of a connection between two nodes based on their shared connections.",
        "colloquial": "Calculates a similarity score between pairs of nodes based on how many neighbors they share compared to their total number of neighbors."
    },
    "adamic_adar_index": {
        "technical": "The Adamic-Adar index is a measure used in link prediction to quantify the similarity between two nodes based on their shared neighbors, giving more weight to less-connected neighbors. For nodes $u$ and $v$, the index is calculated as: $AA(u, v) = \\sum_{w \\in \\Gamma(u) \\cap \\Gamma(v)} \\frac{1}{\\log |\\Gamma(w)|}$ where $\\Gamma(u)$ is the set of neighbors of node $u$, and $w$ ranges over the common neighbors of $u$ and $v$. This metric assigns higher scores to node pairs connected through low-degree common neighbors, reflecting the intuition that shared connections with less popular nodes are more indicative of a potential link between $u$ and $v$. The index is useful in social network analysis and recommendation systems.",
        "colloquial": "Assigns a score to node pairs based on shared neighbors, giving more weight to less connected common neighbors."
    },
    "preferential_attachment": {
        "technical": "Preferential attachment is a principle where the probability of a new link connecting to a node is proportional to the node's degree. In link prediction, the preferential attachment score for nodes $u$ and $v$ is calculated as: $PA(u, v) = |\\Gamma(u)| \\times |\\Gamma(v)|$ where $|\\Gamma(u)|$ is the degree of node $u$. This measure is based on the principle that nodes with higher degrees are more likely to form new connections, mirroring the 'rich get richer' phenomenon observed in many real-world networks. The score is used to predict future links based on the current degree distribution.",
        "colloquial": "Predicts the likelihood of a connection between two nodes based on the idea that nodes with more connections are more likely to connect."
    },
    "all_node_cuts": {
        "technical": "All node cuts of minimum size $k$ in an undirected graph are the minimal sets of nodes whose removal disconnects the graph, and the cardinality of these sets equals the node connectivity of the graph. Kanevsky's algorithm efficiently finds all such minimal node cutsets by exploring local separations and employing maximum flow computations between carefully chosen pairs of nodes. The algorithm operates by considering pairs of non-adjacent nodes and determining whether a minimal separating set of size $k$ exists between them. It systematically enumerates all minimal node cuts without redundancy, making it valuable for network reliability analysis and understanding critical points of failure.",
        "colloquial": "Finds all the smallest sets of nodes that, if removed, would break the network into separate parts."
    },
    "wiener_index": {
        "technical": "The Wiener index of a graph is a topological index defined as the sum of the shortest-path distances between all pairs of nodes in the graph. Mathematically, it is expressed as: $W = \\sum_{u \\neq v} d(u, v)$ where $d(u, v)$ is the shortest-path distance between nodes $u$ and $v$. The Wiener index is used in chemistry for analyzing molecular graphs and in network analysis as a measure of graph compactness. It provides insight into the overall connectivity and average distances within the network.",
        "colloquial": "Adds up the shortest distances between all pairs of nodes to provide a measure of the network's total connectivity."
    },
    "number_of_spanning_trees": {
        "technical": "The number of spanning trees in an undirected graph is a count of all possible trees that include every node of the graph and are acyclic and connected. Kirchhoff's Matrix-Tree Theorem provides a method to calculate this number by computing the determinant of a reduced Laplacian matrix of the graph. Specifically, the number of spanning trees $\\tau$ is given by: $\\tau = \\det(L^*)$ where $L^*$ is any cofactor of the Laplacian matrix $L$ obtained by deleting one row and one column. For weighted graphs, the weights of the edges are incorporated into the Laplacian, and the determinant gives the total weight of all spanning trees. In directed graphs, the analogous concept is the number of spanning arborescences rooted at a particular node, calculated using Tutte's directed version of the Matrix-Tree Theorem.",
        "colloquial": "Counts how many different ways you can connect all the nodes together without forming any loops."
    },
    "girth": {
        "technical": "The girth of a graph is the length of its shortest cycle. If the graph contains no cycles (i.e., it is acyclic), the girth is considered infinite. Determining the girth involves finding the minimal length $g$ such that there exists a cycle of length $g$ in the graph. The girth provides information about the local structure of the graph and is related to concepts like graph expansion and redundancy.",
        "colloquial": "Finds the length of the smallest loop in the network."
    },
    "all_pairs_dijkstra": {
        "technical": "All-pairs shortest paths using Dijkstra's algorithm involve computing the shortest path and its length between every pair of nodes in a weighted graph with non-negative edge weights. Dijkstra's algorithm is applied from each node as the source, yielding the shortest paths to all other reachable nodes. The overall computational complexity is $O(n(m + n \\log n))$, where $n$ is the number of nodes and $m$ is the number of edges. The result is a comprehensive mapping of shortest paths and distances for the entire graph, useful in network optimization and routing applications.",
        "colloquial": "Computes the shortest paths and distances between all pairs of nodes using a method that considers the smallest total edge weight."
    },
    "all_pairs_shortest_path_length": {
        "technical": "The all-pairs shortest path lengths in a graph are the minimal distances between every pair of nodes. These distances can be computed using algorithms such as Dijkstra's algorithm for graphs with non-negative edge weights or Bellman-Ford for graphs with negative weights (but no negative cycles). The result is a matrix or mapping that provides the shortest path length $d(u, v)$ for each node pair $(u, v)$. This information is fundamental in network analysis, enabling calculations of average path lengths, diameters, and centralities.",
        "colloquial": "Computes how far apart each pair of points is in the network, giving you the shortest distance between every pair of nodes."
    },
    "all_pairs_dijkstra_path_length": {
        "technical": "This computation involves determining the lengths of the shortest paths between all pairs of nodes in a graph with non-negative edge weights using Dijkstra's algorithm. For each node $u$, Dijkstra's algorithm computes the shortest path lengths $d(u, v)$ to all other nodes $v$. Repeating this process for every node yields the complete set of shortest path lengths in the graph. The primary focus here is on the path lengths rather than the paths themselves, which reduces computational and storage requirements when only distances are needed.",
        "colloquial": "Finds the shortest distances between all points in the network, taking into account the weights or costs on the connections."
    },
    "all_pairs_bellman_ford_path_length": {
        "technical": "The Bellman-Ford algorithm is used to compute shortest path lengths between all pairs of nodes in graphs that may have negative edge weights but no negative cycles. For each node $u$, the algorithm computes the shortest path lengths $d(u, v)$ to all other nodes $v$ by iteratively relaxing edges. This process accounts for the possibility of negative weight edges, which cannot be handled by Dijkstra's algorithm. The result is the set of shortest path lengths between all node pairs, essential for analyses involving networks with varying edge weights.",
        "colloquial": "Calculates the shortest distances between all points in the network, even if some connections have negative costs."
    },
    "all_pairs_shortest_path": {
        "technical": "All-pairs shortest paths computation aims to find the shortest paths between every pair of nodes in a graph. Algorithms like Floyd-Warshall or repeated applications of Dijkstra's algorithm (for graphs with non-negative weights) are employed. The output is a mapping from each node $u$ to a sub-mapping of nodes $v$ with their corresponding shortest paths $p(u, v)$. This comprehensive set of paths is instrumental in network routing, navigation systems, and understanding the connectivity structure of the network.",
        "colloquial": "Finds the quickest routes between every pair of points in the network, showing you how to get from any node to any other in the shortest way."
    },
    "all_pairs_dijkstra_path": {
        "technical": "Using Dijkstra's algorithm, the shortest paths between all pairs of nodes in a weighted graph are computed. For each source node $u$, the algorithm generates the shortest paths $p(u, v)$ to all other nodes $v$. By iterating over all nodes as sources, the complete set of shortest paths in the network is obtained. These paths are essential for applications requiring precise routing information, such as communication networks and transportation planning.",
        "colloquial": "Calculates the best routes between all points in the network, taking into account the costs or weights of the connections."
    },
    "all_pairs_bellman_ford_path": {
        "technical": "The Bellman-Ford algorithm computes shortest paths from a single source node $u$ to all other nodes $v$ in a graph that may contain negative edge weights but no negative cycles. By applying the algorithm from each node in the graph, the shortest paths between all pairs of nodes are determined. The resulting paths $p(u, v)$ capture the optimal routes considering the potentially negative weights, which can represent gains or losses in network flows or costs.",
        "colloquial": "Finds the best ways to travel between all points in the network, even when some connections can have negative costs."
    },
    "global_efficiency": {
        "technical": "Global efficiency is a measure of how efficiently information or resources are exchanged over a network. It is defined as the average of the inverse shortest path lengths between all pairs of nodes: $E_{glob} = \\frac{1}{n(n - 1)} \\sum_{u \\neq v} \\frac{1}{d(u, v)}$ where $n$ is the number of nodes, and $d(u, v)$ is the shortest-path distance between nodes $u$ and $v$. A higher global efficiency indicates that the network, on average, allows for quick communication between nodes. This metric is applicable to both connected and disconnected graphs, assigning an efficiency of zero to pairs of nodes that are not connected.",
        "colloquial": "Calculates how efficiently information or resources can be exchanged over the whole network."
    },
    "local_efficiency": {
        "technical": "Local efficiency measures how efficiently information or resources are exchanged in the local neighborhoods of the network. For each node $v$, it is defined as the global efficiency of the subgraph induced by the neighbors of $v$, excluding $v$ itself. Mathematically: $E_{loc}(v) = \\frac{1}{k_v(k_v - 1)} \\sum_{i \\neq j \\in \\Gamma(v)} \\frac{1}{d(i, j)}$ where $k_v$ is the degree of node $v$, $\\Gamma(v)$ is the set of neighbors of $v$, and $d(i, j)$ is the shortest-path distance between nodes $i$ and $j$ within the neighborhood. The average local efficiency over all nodes provides insight into the fault tolerance of the network, indicating how well the network sustains communication when individual nodes are removed.",
        "colloquial": "Measures how well information or resources can be exchanged within a node's immediate neighborhood."
    },
    "triadic_census": {
        "technical": "The triadic census is a count of all triad types in a directed graph. A triad consists of three nodes and the possible directed edges among them. There are 16 distinct triad types, each representing a unique pattern of connections. The census provides a profile of the network's local structure, revealing tendencies toward reciprocity, hierarchy, or other structural features. The counts of each triad type can be used to compare different networks or to assess the fit of network models.",
        "colloquial": "Counts the different ways three nodes can be connected in the network."
    },
    "k_shell": {
        "technical": "The $k$-shell of a graph is the subgraph formed by recursively removing all nodes with degree less than $k$ until no such nodes remain. The process assigns a core number $k$ to each node, indicating the highest $k$-shell to which it belongs. Nodes in higher $k$-shells are more centrally connected within the network's core structure. The $k$-shell decomposition reveals hierarchical layers in the network, with the innermost core representing the most interconnected and potentially influential nodes.",
        "colloquial": "Extracts the layer of nodes that have a specific number of connections, revealing the network's structure at different levels."
    },
    "percolation_centrality": {
        "technical": "Percolation centrality measures the influence of nodes in dynamic processes where the node states affect the spread of information or contagion, such as in percolation or epidemic models. For a node $v$ at time $t$, the percolation centrality $PC_t(v)$ is defined as: $PC_t(v) = \\sum_{s \\neq v \\neq t} \\frac{\\sigma_{st}(v, t)}{\\sigma_{st}(t)} p(v, t)$ where $\\sigma_{st}(v, t)$ is the number of percolated shortest paths from $s$ to $t$ passing through $v$ at time $t$, $\\sigma_{st}(t)$ is the total number of percolated shortest paths from $s$ to $t$, and $p(v, t)$ is the percolation state of $v$ at time $t$. This centrality reflects both the topological position of a node and its current state, capturing its dynamic importance in the spreading process.",
        "colloquial": "Measures how important a node is in spreading something through the network, considering both its connections and its current state."
    },
    "closeness_vitality": {
        "technical": "Closeness vitality of a node is the change in the sum of distances between all pairs of nodes when that node is removed from the graph. For a node $v$, the closeness vitality $CV(v)$ is calculated as: $CV(v) = \\sum_{s \\neq t} d_{G}(s, t) - \\sum_{s \\neq t} d_{G \\setminus v}(s, t)$ where $d_{G}(s, t)$ is the shortest-path distance between nodes $s$ and $t$ in the original graph $G$, and $d_{G \\setminus v}(s, t)$ is the distance in the graph with node $v$ removed. A high closeness vitality indicates that the node plays a significant role in maintaining short paths within the network, and its removal would substantially increase the overall path lengths.",
        "colloquial": "Shows how much a node contributes to keeping the network efficiently connected by seeing how the total distance between nodes changes if it's removed."
    },
    "edge_current_flow_betweenness_centrality": {
        "technical": "Edge current-flow betweenness centrality is a measure of the importance of edges based on the flow of electrical current in the network. It considers all possible paths between node pairs, weighted by their effective resistance. The centrality of an edge $e$ is calculated by applying Kirchhoff's laws to compute the current flowing through $e$ when unit current is injected between all pairs of nodes. Mathematically, it sums the absolute current flows over all node pairs, reflecting how critical the edge is for the overall connectivity and flow in the network.",
        "colloquial": "Measures how important each connection is for the flow of information through the network, considering all possible routes."
    },
    "algebraic_connectivity": {
        "technical": "Algebraic connectivity of a graph is the second-smallest eigenvalue $\\lambda_2$ of the Laplacian matrix $L$ of the graph. It provides a spectral measure of the graph's connectivity. A higher algebraic connectivity indicates a more robust and well-connected network. The Laplacian matrix is defined as $L = D - A$, where $D$ is the degree matrix and $A$ is the adjacency matrix. The eigenvalues of $L$ are real and non-negative, and $\\lambda_2$ being greater than zero indicates that the graph is connected. Algebraic connectivity is related to various graph properties, such as the expansion properties and the graph's ability to withstand node or edge removals.",
        "colloquial": "Determines how strongly connected the network is overall, indicating how difficult it is to separate into disconnected parts."
    },
    "node_connectivity": {
        "technical": "Node connectivity, or vertex connectivity, of a graph is the minimum number of nodes that must be removed to disconnect the graph or reduce it to a trivial graph (one with a single node). Formally, it is the size of the smallest vertex cut. For two distinct nodes $s$ and $t$, the local node connectivity is the minimum number of nodes that must be removed to eliminate all paths between $s$ and $t$. Node connectivity is a measure of the graph's resilience to node failures and its overall robustness.",
        "colloquial": "Shows the minimum number of nodes that need to be removed to break the network apart or to disconnect specific nodes."
    },
    "katz_centrality": {
        "technical": "Katz centrality measures the influence of a node in a network by considering the total number of walks that connect the node to others, attenuated by a factor $\\alpha$. The centrality $x_i$ of node $i$ is given by: $x_i = \\alpha \\sum_{j} A_{ij} x_j + \\beta$ where $A_{ij}$ is the element of the adjacency matrix $A$ representing the connection from node $j$ to node $i$, $\\alpha$ is a damping factor (satisfying $\\alpha < 1 / \\lambda_{\\text{max}}$, where $\\lambda_{\\text{max}}$ is the largest eigenvalue of $A$), and $\\beta$ is an exogenous factor representing external influence. Katz centrality accounts for both immediate neighbors and the broader reach of a node through the network, with longer paths contributing less due to the attenuation.",
        "colloquial": "Measures a node's importance by counting all paths leading to it, giving more weight to shorter paths. Nodes connected to many others, even indirectly, score higher."
    },
    "voterank": {
        "technical": "VoteRank is an algorithm designed to identify influential nodes in a network for efficient information spread or monitoring. The algorithm operates iteratively, where in each step, nodes vote for their neighbors, and the node with the highest cumulative votes is selected as influential. After each selection, the voting ability of the chosen node and its immediate neighbors is decreased to prevent them from dominating subsequent rounds. This process continues until a predefined number of influential nodes is identified or no nodes receive votes. VoteRank is effective in selecting a set of nodes that collectively cover the network efficiently.",
        "colloquial": "Finds key players in a network by having nodes 'vote' for their neighbors. Nodes with the most votes are picked as important, resulting in a list of top influencers."
    },
    "current_flow_betweenness_centrality": {
        "technical": "Current-flow betweenness centrality is a measure of node importance based on the flow of electrical current in the network. Unlike traditional betweenness centrality, which considers only the shortest paths, current-flow betweenness centrality takes into account all possible paths between nodes. The algorithm applies Kirchhoff's laws to compute the current flow through each node when unit current is injected between all pairs of nodes. This method ensures that nodes with multiple paths contributing to flow will have higher centrality values. The computation involves solving a system of linear equations based on the graph's Laplacian matrix, which models the network as an electrical circuit. The resulting centrality values provide insights into the node's role in facilitating the overall connectivity and flow in the graph.",
        "colloquial": "Measures how important each node is for the flow of information through the network, taking into account all possible routes like electrical currents."
    }
}
