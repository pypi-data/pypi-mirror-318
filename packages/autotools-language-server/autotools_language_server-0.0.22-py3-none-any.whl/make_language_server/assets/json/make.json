{
  "$id": "https://github.com/Freed-Wu/autotools-language-server/blob/main/src/termux_language_server/assets/json/make.json",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$comment": "Don't edit this file directly! It is generated by `autotools-language-server --generate-schema=make`.",
  "type": "object",
  "properties": {
    "all": {
      "description": "Compile the entire program.  This should be the default target. This target need not rebuild any documentation files; Info files should normally be included in the distribution, and DVI (and other documentation format) files should be made only when explicitly asked for. By default, the Make rules should compile and link with '-g', so that executable programs have debugging symbols.  Otherwise, you are essentially helpless in the face of a crash, and it is often far from easy to reproduce with a fresh build."
    },
    "clean": {
      "description": "Delete all files in the current directory that are normally created by building the program.  Also delete files in other directories if they are created by this makefile.  However, don't delete the files that record the configuration.  Also preserve files that could be made by building, but normally aren't because the distribution comes with them.  There is no need to delete parent directories that were created with 'mkdir -p', since they could have existed anyway. Delete '.dvi' files here if they are not part of the distribution."
    },
    "mostlyclean": {
      "description": "Like 'clean', but may refrain from deleting a few files that people normally don't want to recompile.  For example, the 'mostlyclean' target for GCC does not delete 'libgcc.a', because recompiling it is rarely necessary and takes a lot of time."
    },
    "distclean": {
      "description": "Delete all files in the current directory (or created by this makefile) that are created by configuring or building the program. If you have unpacked the source and built the program without creating any other files, 'make distclean' should leave only the files that were in the distribution.  However, there is no need to delete parent directories that were created with 'mkdir -p', since they could have existed anyway."
    },
    "realclean": {
      "description": "```make\ndistclean\nrealclean\nclobber\n```\nAny of these targets might be defined to delete _more_ files than 'clean' does.  For example, this would delete configuration files or links that you would normally create as preparation for compilation, even if the makefile itself cannot create these files."
    },
    "clobber": {
      "description": "```make\ndistclean\nrealclean\nclobber\n```\nAny of these targets might be defined to delete _more_ files than 'clean' does.  For example, this would delete configuration files or links that you would normally create as preparation for compilation, even if the makefile itself cannot create these files."
    },
    "install": {
      "description": "Compile the program and copy the executables, libraries, and so on to the file names where they should reside for actual use.  If there is a simple test to verify that a program is properly installed, this target should run that test. Do not strip executables when installing them.  This helps eventual debugging that may be needed later, and nowadays disk space is cheap and dynamic loaders typically ensure debug sections are not loaded during normal execution.  Users that need stripped binaries may invoke the 'install-strip' target to do that. If possible, write the 'install' target rule so that it does not modify anything in the directory where the program was built, provided 'make all' has just been done.  This is convenient for building the program under one user name and installing it under another. The commands should create all the directories in which files are to be installed, if they don't already exist.  This includes the directories specified as the values of the variables 'prefix' and 'exec_prefix', as well as all subdirectories that are needed.  One way to do this is by means of an 'installdirs' target as described below. Use '-' before any command for installing a man page, so that 'make' will ignore any errors.  This is in case there are systems that don't have the Unix man page documentation system installed. The way to install Info files is to copy them into '$(infodir)' with '$(INSTALL_DATA)' (*note Command Variables::), and then run the 'install-info' program if it is present.  'install-info' is a program that edits the Info 'dir' file to add or update the menu entry for the given Info file; it is part of the Texinfo package. Here is a sample rule to install an Info file that also tries to handle some additional situations, such as 'install-info' not being present. do-install-info: foo.info installdirs $(NORMAL_INSTALL) # Prefer an info file in . to one in srcdir. if test -f foo.info; then d=.; \\ else d=\"$(srcdir)\"; fi; \\ $(INSTALL_DATA) $$d/foo.info \\ \"$(DESTDIR)$(infodir)/foo.info\" # Run install-info only if it exists. # Use 'if' instead of just prepending '-' to the # line so we notice real errors from install-info. # Use '$(SHELL) -c' because some shells do not # fail gracefully when there is an unknown command. $(POST_INSTALL) if $(SHELL) -c 'install-info --version' \\ >/dev/null 2>&1; then \\ install-info --dir-file=\"$(DESTDIR)$(infodir)/dir\" \\ \"$(DESTDIR)$(infodir)/foo.info\"; \\ else true; fi When writing the 'install' target, you must classify all the commands into three categories: normal ones, \"pre-installation\" commands and \"post-installation\" commands.  *Note Install Command Categories::."
    },
    "print": {
      "description": "Print listings of the source files that have changed."
    },
    "tar": {
      "description": "Create a tar file of the source files."
    },
    "shar": {
      "description": "Create a shell archive (shar file) of the source files."
    },
    "dist": {
      "description": "Create a distribution tar file for this program.  The tar file should be set up so that the file names in the tar file start with a subdirectory name which is the name of the package it is a distribution for.  This name can include the version number. For example, the distribution tar file of GCC version 1.40 unpacks into a subdirectory named 'gcc-1.40'. The easiest way to do this is to create a subdirectory appropriately named, use 'ln' or 'cp' to install the proper files in it, and then 'tar' that subdirectory. Compress the tar file with 'gzip'.  For example, the actual distribution file for GCC version 1.40 is called 'gcc-1.40.tar.gz'. It is ok to support other free compression formats as well. The 'dist' target should explicitly depend on all non-source files that are in the distribution, to make sure they are up to date in the distribution.  *Note Making Releases: (standards)Releases."
    },
    "TAGS": {
      "description": "Update a tags table for this program."
    },
    "check": {
      "description": "Perform self-tests (if any).  The user must build the program before running the tests, but need not install the program; you should write the self-tests so that they work when the program is built but not installed."
    },
    "test": {
      "description": "```make\ncheck\ntest\n```\nPerform self tests on the program this makefile builds."
    },
    "AR": {
      "description": "Archive-maintaining program; default 'ar'."
    },
    "AS": {
      "description": "Program for compiling assembly files; default 'as'."
    },
    "CC": {
      "description": "Program for compiling C programs; default 'cc'."
    },
    "CXX": {
      "description": "Program for compiling C++ programs; default 'g++'."
    },
    "CPP": {
      "description": "Program for running the C preprocessor, with results to standard output; default '$(CC) -E'."
    },
    "FC": {
      "description": "Program for compiling or preprocessing Fortran and Ratfor programs; default 'f77'."
    },
    "M2C": {
      "description": "Program to use to compile Modula-2 source code; default 'm2c'."
    },
    "PC": {
      "description": "Program for compiling Pascal programs; default 'pc'."
    },
    "CO": {
      "description": "Program for extracting a file from RCS; default 'co'."
    },
    "GET": {
      "description": "Program for extracting a file from SCCS; default 'get'."
    },
    "LEX": {
      "description": "Program to use to turn Lex grammars into source code; default 'lex'."
    },
    "YACC": {
      "description": "Program to use to turn Yacc grammars into source code; default 'yacc'."
    },
    "LINT": {
      "description": "Program to use to run lint on source code; default 'lint'."
    },
    "MAKEINFO": {
      "description": "Program to convert a Texinfo source file into an Info file; default 'makeinfo'."
    },
    "TEX": {
      "description": "Program to make TeX DVI files from TeX source; default 'tex'."
    },
    "TEXI2DVI": {
      "description": "Program to make TeX DVI files from Texinfo source; default 'texi2dvi'."
    },
    "WEAVE": {
      "description": "Program to translate Web into TeX; default 'weave'."
    },
    "CWEAVE": {
      "description": "Program to translate C Web into TeX; default 'cweave'."
    },
    "TANGLE": {
      "description": "Program to translate Web into Pascal; default 'tangle'."
    },
    "CTANGLE": {
      "description": "Program to translate C Web into C; default 'ctangle'."
    },
    "RM": {
      "description": "Command to remove a file; default 'rm -f'."
    },
    "ARFLAGS": {
      "description": "Flags to give the archive-maintaining program; default 'rv'."
    },
    "ASFLAGS": {
      "description": "Extra flags to give to the assembler (when explicitly invoked on a '.s' or '.S' file)."
    },
    "CFLAGS": {
      "description": "Extra flags to give to the C compiler."
    },
    "CXXFLAGS": {
      "description": "Extra flags to give to the C++ compiler."
    },
    "COFLAGS": {
      "description": "Extra flags to give to the RCS 'co' program."
    },
    "CPPFLAGS": {
      "description": "Extra flags to give to the C preprocessor and programs that use it (the C and Fortran compilers)."
    },
    "FFLAGS": {
      "description": "Extra flags to give to the Fortran compiler."
    },
    "GFLAGS": {
      "description": "Extra flags to give to the SCCS 'get' program."
    },
    "LDFLAGS": {
      "description": "Extra flags to give to compilers when they are supposed to invoke the linker, 'ld', such as '-L'.  Libraries ('-lfoo') should be added to the 'LDLIBS' variable instead."
    },
    "LDLIBS": {
      "description": "Library flags or names given to compilers when they are supposed to invoke the linker, 'ld'.  'LOADLIBES' is a deprecated (but still supported) alternative to 'LDLIBS'.  Non-library linker flags, such as '-L', should go in the 'LDFLAGS' variable."
    },
    "LFLAGS": {
      "description": "Extra flags to give to Lex."
    },
    "YFLAGS": {
      "description": "Extra flags to give to Yacc."
    },
    "PFLAGS": {
      "description": "Extra flags to give to the Pascal compiler."
    },
    "RFLAGS": {
      "description": "Extra flags to give to the Fortran compiler for Ratfor programs."
    },
    "LINTFLAGS": {
      "description": "Extra flags to give to lint."
    },
    "parse.tab.h',": {
      "description": "```make\nparse.tab.h', when 'parse.y' is changed, the recipe 'bison -d parse.y\n```\n"
    },
    "@": {
      "description": "```make\n$@\n```\nThe file name of the target."
    },
    "%": {
      "description": "```make\n$%\n```\nThe target member name, when the target is an archive member."
    },
    "<": {
      "description": "```make\n$<\n```\nThe name of the first prerequisite."
    },
    "?": {
      "description": "```make\n$?\n```\nThe names of all the prerequisites that are newer than the target, with spaces between them.  For prerequisites which are archive members, only the named member is used (*note Archives::)."
    },
    "^": {
      "description": "```make\n$^\n$+\n```\nThe names of all the prerequisites, with spaces between them.  For prerequisites which are archive members, only the named member is used (*note Archives::).  The value of '$^' omits duplicate prerequisites, while '$+' retains them and preserves their order."
    },
    "+": {
      "description": "```make\n$^\n$+\n```\nThe names of all the prerequisites, with spaces between them.  For prerequisites which are archive members, only the named member is used (*note Archives::).  The value of '$^' omits duplicate prerequisites, while '$+' retains them and preserves their order."
    },
    "|": {
      "description": "```make\n$|\n```\nThe names of all the order-only prerequisites, with spaces between them."
    },
    "*": {
      "description": "```make\n$*\n```\nThe stem with which an implicit rule matches (*note How Patterns Match: Pattern Match.)."
    },
    "@D": {
      "description": "```make\n$(@D)\n$(@F)\n```\nThe directory part and the file-within-directory part of '$@'."
    },
    "@F": {
      "description": "```make\n$(@D)\n$(@F)\n```\nThe directory part and the file-within-directory part of '$@'."
    },
    "*D": {
      "description": "```make\n$(*D)\n$(*F)\n```\nThe directory part and the file-within-directory part of '$*'."
    },
    "*F": {
      "description": "```make\n$(*D)\n$(*F)\n```\nThe directory part and the file-within-directory part of '$*'."
    },
    "%D": {
      "description": "```make\n$(%D)\n$(%F)\n```\nThe directory part and the file-within-directory part of '$%'."
    },
    "%F": {
      "description": "```make\n$(%D)\n$(%F)\n```\nThe directory part and the file-within-directory part of '$%'."
    },
    "<D": {
      "description": "```make\n$(<D)\n$(<F)\n```\nThe directory part and the file-within-directory part of '$<'."
    },
    "<F": {
      "description": "```make\n$(<D)\n$(<F)\n```\nThe directory part and the file-within-directory part of '$<'."
    },
    "^D": {
      "description": "```make\n$(^D)\n$(^F)\n```\nThe directory part and the file-within-directory part of '$^'."
    },
    "^F": {
      "description": "```make\n$(^D)\n$(^F)\n```\nThe directory part and the file-within-directory part of '$^'."
    },
    "+D": {
      "description": "```make\n$(+D)\n$(+F)\n```\nThe directory part and the file-within-directory part of '$+'."
    },
    "+F": {
      "description": "```make\n$(+D)\n$(+F)\n```\nThe directory part and the file-within-directory part of '$+'."
    },
    "?D": {
      "description": "```make\n$(?D)\n$(?F)\n```\nThe directory part and the file-within-directory part of '$?'."
    },
    "?F": {
      "description": "```make\n$(?D)\n$(?F)\n```\nThe directory part and the file-within-directory part of '$?'."
    },
    "bar.f'": {
      "description": "```make\nbar.f' exist, 'make' will choose the first rule and compile 'bar.c\n```\n"
    },
    "#f": {
      "description": "False is converted into the empty string: in 'make' conditionals the empty string is considered false."
    },
    "#t": {
      "description": "True is converted to the string '#t': in 'make' conditionals any non-empty string is considered true."
    },
    "symbol": {
      "description": "```make\nsymbol\nnumber\n```\nA symbol or number is converted into the string representation of that symbol or number."
    },
    "number": {
      "description": "```make\nsymbol\nnumber\n```\nA symbol or number is converted into the string representation of that symbol or number."
    },
    "character": {
      "description": "A printable character is converted to the same character."
    },
    "string": {
      "description": "A string containing only printable characters is converted to the same string."
    },
    "list": {
      "description": "A list is converted recursively according to the above rules.  This implies that any structured list will be flattened (that is, a result of ''(a b (c d) e)' will be converted to the 'make' string 'a b c d e')."
    },
    "other": {
      "description": "Any other Guile type results in an error.  In future versions of 'make', other Guile types may be converted."
    },
    "gmk-expand": {
      "description": "This procedure takes a single argument which is converted into a string.  The string is expanded by 'make' using normal 'make' expansion rules.  The result of the expansion is converted into a Guile string and provided as the result of the procedure."
    },
    "gmk-eval": {
      "description": "This procedure takes a single argument which is converted into a string.  The string is evaluated by 'make' as if it were a makefile.  This is the same capability available via the 'eval' function (*note Eval Function::).  The result of the 'gmk-eval' procedure is always the empty string. Note that 'gmk-eval' is not quite the same as using 'gmk-expand' with the 'eval' function: in the latter case the evaluated string will be expanded _twice_; first by 'gmk-expand', then again by the 'eval' function."
    },
    "gmk_floc": {
      "description": "This structure represents a filename/location pair.  It is provided when defining items, so GNU 'make' can inform the user later where the definition occurred if necessary."
    },
    "name": {
      "description": "The function name.  This is what the makefile should use to invoke the function.  The name must be between 1 and 255 characters long and it may only contain alphanumeric, period ('.'), dash ('-'), and underscore ('_') characters.  It may not begin with a period."
    },
    "func_ptr": {
      "description": "A pointer to a function that 'make' will invoke when it expands the function in a makefile.  This function must be defined by the loaded object."
    },
    "min_args": {
      "description": "The minimum number of arguments the function will accept.  Must be between 0 and 255.  GNU 'make' will check this and fail before invoking 'func_ptr' if the function was invoked with too few arguments."
    },
    "max_args": {
      "description": "The maximum number of arguments the function will accept.  Must be between 0 and 255.  GNU 'make' will check this and fail before invoking 'func_ptr' if the function was invoked with too many arguments.  If the value is 0, then any number of arguments is accepted.  If the value is greater than 0, then it must be greater than or equal to 'min_args'."
    },
    "flags": {
      "description": "Flags that specify how this function will operate; the desired flags should be OR'd together.  If the 'GMK_FUNC_NOEXPAND' flag is given then the function arguments will not be expanded before the function is called; otherwise they will be expanded first."
    },
    "gmk_expand": {
      "description": "This function takes a string and expands it using 'make' expansion rules.  The result of the expansion is returned in a nil-terminated string buffer.  The caller is responsible for calling 'gmk_free' with a pointer to the returned buffer when done."
    },
    "gmk_eval": {
      "description": "This function takes a buffer and evaluates it as a segment of makefile syntax.  This function can be used to define new variables, new rules, etc.  It is equivalent to using the 'eval' 'make' function."
    },
    "gmk_alloc": {
      "description": "Return a pointer to a newly-allocated buffer.  This function will always return a valid pointer; if not enough memory is available 'make' will exit.  'gmk_alloc' does not initialize allocated memory."
    },
    "gmk_free": {
      "description": "Free a buffer returned to you by 'make'.  Once the 'gmk_free' function returns the string will no longer be valid.  If NULL is passed to 'gmk_free', no operation is performed."
    },
    "DESTDIR'": {
      "description": "```make\nDESTDIR' should be supported only in the 'install*' and 'uninstall*\n```\n"
    },
    "prefix": {
      "description": "A prefix used in constructing the default values of the variables listed below.  The default value of 'prefix' should be '/usr/local'.  When building the complete GNU system, the prefix will be empty and '/usr' will be a symbolic link to '/'.  (If you are using Autoconf, write it as '@prefix@'.) Running 'make install' with a different value of 'prefix' from the one used to build the program should _not_ recompile the program."
    },
    "exec_prefix": {
      "description": "A prefix used in constructing the default values of some of the variables listed below.  The default value of 'exec_prefix' should be '$(prefix)'.  (If you are using Autoconf, write it as '@exec_prefix@'.) Generally, '$(exec_prefix)' is used for directories that contain machine-specific files (such as executables and subroutine libraries), while '$(prefix)' is used directly for other directories. Running 'make install' with a different value of 'exec_prefix' from the one used to build the program should _not_ recompile the program."
    },
    "bindir": {
      "description": "The directory for installing executable programs that users can run.  This should normally be '/usr/local/bin', but write it as '$(exec_prefix)/bin'.  (If you are using Autoconf, write it as '@bindir@'.)"
    },
    "sbindir": {
      "description": "The directory for installing executable programs that can be run from the shell, but are only generally useful to system administrators.  This should normally be '/usr/local/sbin', but write it as '$(exec_prefix)/sbin'.  (If you are using Autoconf, write it as '@sbindir@'.)"
    },
    "libexecdir": {
      "description": "The directory for installing executable programs to be run by other programs rather than by users.  This directory should normally be '/usr/local/libexec', but write it as '$(exec_prefix)/libexec'. (If you are using Autoconf, write it as '@libexecdir@'.) The definition of 'libexecdir' is the same for all packages, so you should install your data in a subdirectory thereof.  Most packages install their data under '$(libexecdir)/PACKAGE-NAME/', possibly within additional subdirectories thereof, such as '$(libexecdir)/PACKAGE-NAME/MACHINE/VERSION'."
    },
    "datarootdir": {
      "description": "The root of the directory tree for read-only architecture-independent data files.  This should normally be '/usr/local/share', but write it as '$(prefix)/share'.  (If you are using Autoconf, write it as '@datarootdir@'.)  'datadir''s default value is based on this variable; so are 'infodir', 'mandir', and others."
    },
    "datadir": {
      "description": "The directory for installing idiosyncratic read-only architecture-independent data files for this program.  This is usually the same place as 'datarootdir', but we use the two separate variables so that you can move these program-specific files without altering the location for Info files, man pages, etc. This should normally be '/usr/local/share', but write it as '$(datarootdir)'.  (If you are using Autoconf, write it as '@datadir@'.) The definition of 'datadir' is the same for all packages, so you should install your data in a subdirectory thereof.  Most packages install their data under '$(datadir)/PACKAGE-NAME/'."
    },
    "sysconfdir": {
      "description": "The directory for installing read-only data files that pertain to a single machine-that is to say, files for configuring a host. Mailer and network configuration files, '/etc/passwd', and so forth belong here.  All the files in this directory should be ordinary ASCII text files.  This directory should normally be '/usr/local/etc', but write it as '$(prefix)/etc'.  (If you are using Autoconf, write it as '@sysconfdir@'.) Do not install executables here in this directory (they probably belong in '$(libexecdir)' or '$(sbindir)').  Also do not install files that are modified in the normal course of their use (programs whose purpose is to change the configuration of the system excluded).  Those probably belong in '$(localstatedir)'."
    },
    "sharedstatedir": {
      "description": "The directory for installing architecture-independent data files which the programs modify while they run.  This should normally be '/usr/local/com', but write it as '$(prefix)/com'.  (If you are using Autoconf, write it as '@sharedstatedir@'.)"
    },
    "localstatedir": {
      "description": "The directory for installing data files which the programs modify while they run, and that pertain to one specific machine.  Users should never need to modify files in this directory to configure the package's operation; put such configuration information in separate files that go in '$(datadir)' or '$(sysconfdir)'. '$(localstatedir)' should normally be '/usr/local/var', but write it as '$(prefix)/var'.  (If you are using Autoconf, write it as '@localstatedir@'.)"
    },
    "runstatedir": {
      "description": "The directory for installing data files which the programs modify while they run, that pertain to one specific machine, and which need not persist longer than the execution of the program--which is generally long-lived, for example, until the next reboot.  PID files for system daemons are a typical use.  In addition, this directory should not be cleaned except perhaps at reboot, while the general '/tmp' ('TMPDIR') may be cleaned arbitrarily.  This should normally be '/var/run', but write it as '$(localstatedir)/run'. Having it as a separate variable allows the use of '/run' if desired, for example.  (If you are using Autoconf 2.70 or later, write it as '@runstatedir@'.)"
    },
    "includedir": {
      "description": "The directory for installing header files to be included by user programs with the C '#include' preprocessor directive.  This should normally be '/usr/local/include', but write it as '$(prefix)/include'.  (If you are using Autoconf, write it as '@includedir@'.) Most compilers other than GCC do not look for header files in directory '/usr/local/include'.  So installing the header files this way is only useful with GCC.  Sometimes this is not a problem because some libraries are only really intended to work with GCC. But some libraries are intended to work with other compilers.  They should install their header files in two places, one specified by 'includedir' and one specified by 'oldincludedir'."
    },
    "oldincludedir": {
      "description": "The directory for installing '#include' header files for use with compilers other than GCC.  This should normally be '/usr/include'. (If you are using Autoconf, you can write it as '@oldincludedir@'.) The Makefile commands should check whether the value of 'oldincludedir' is empty.  If it is, they should not try to use it; they should cancel the second installation of the header files. A package should not replace an existing header in this directory unless the header came from the same package.  Thus, if your Foo package provides a header file 'foo.h', then it should install the header file in the 'oldincludedir' directory if either (1) there is no 'foo.h' there or (2) the 'foo.h' that exists came from the Foo package. To tell whether 'foo.h' came from the Foo package, put a magic string in the file--part of a comment--and 'grep' for that string."
    },
    "docdir": {
      "description": "The directory for installing documentation files (other than Info) for this package.  By default, it should be '/usr/local/share/doc/YOURPKG', but it should be written as '$(datarootdir)/doc/YOURPKG'.  (If you are using Autoconf, write it as '@docdir@'.)  The YOURPKG subdirectory, which may include a version number, prevents collisions among files with common names, such as 'README'."
    },
    "infodir": {
      "description": "The directory for installing the Info files for this package.  By default, it should be '/usr/local/share/info', but it should be written as '$(datarootdir)/info'.  (If you are using Autoconf, write it as '@infodir@'.)  'infodir' is separate from 'docdir' for compatibility with existing practice."
    },
    "htmldir": {
      "description": "```make\nhtmldir\ndvidir\npdfdir\npsdir\n```\nDirectories for installing documentation files in the particular format.  They should all be set to '$(docdir)' by default.  (If you are using Autoconf, write them as '@htmldir@', '@dvidir@', etc.) Packages which supply several translations of their documentation should install them in '$(htmldir)/'LL, '$(pdfdir)/'LL, etc.  where LL is a locale abbreviation such as 'en' or 'pt_BR'."
    },
    "dvidir": {
      "description": "```make\nhtmldir\ndvidir\npdfdir\npsdir\n```\nDirectories for installing documentation files in the particular format.  They should all be set to '$(docdir)' by default.  (If you are using Autoconf, write them as '@htmldir@', '@dvidir@', etc.) Packages which supply several translations of their documentation should install them in '$(htmldir)/'LL, '$(pdfdir)/'LL, etc.  where LL is a locale abbreviation such as 'en' or 'pt_BR'."
    },
    "pdfdir": {
      "description": "```make\nhtmldir\ndvidir\npdfdir\npsdir\n```\nDirectories for installing documentation files in the particular format.  They should all be set to '$(docdir)' by default.  (If you are using Autoconf, write them as '@htmldir@', '@dvidir@', etc.) Packages which supply several translations of their documentation should install them in '$(htmldir)/'LL, '$(pdfdir)/'LL, etc.  where LL is a locale abbreviation such as 'en' or 'pt_BR'."
    },
    "psdir": {
      "description": "```make\nhtmldir\ndvidir\npdfdir\npsdir\n```\nDirectories for installing documentation files in the particular format.  They should all be set to '$(docdir)' by default.  (If you are using Autoconf, write them as '@htmldir@', '@dvidir@', etc.) Packages which supply several translations of their documentation should install them in '$(htmldir)/'LL, '$(pdfdir)/'LL, etc.  where LL is a locale abbreviation such as 'en' or 'pt_BR'."
    },
    "libdir": {
      "description": "The directory for object files and libraries of object code.  Do not install executables here, they probably ought to go in '$(libexecdir)' instead.  The value of 'libdir' should normally be '/usr/local/lib', but write it as '$(exec_prefix)/lib'.  (If you are using Autoconf, write it as '@libdir@'.)"
    },
    "lispdir": {
      "description": "The directory for installing any Emacs Lisp files in this package. By default, it should be '/usr/local/share/emacs/site-lisp', but it should be written as '$(datarootdir)/emacs/site-lisp'. If you are using Autoconf, write the default as '@lispdir@'.  In order to make '@lispdir@' work, you need the following lines in your 'configure.ac' file: lispdir='${datarootdir}/emacs/site-lisp' AC_SUBST(lispdir)"
    },
    "localedir": {
      "description": "The directory for installing locale-specific message catalogs for this package.  By default, it should be '/usr/local/share/locale', but it should be written as '$(datarootdir)/locale'.  (If you are using Autoconf, write it as '@localedir@'.)  This directory usually has a subdirectory per locale."
    },
    "mandir": {
      "description": "The top-level directory for installing the man pages (if any) for this package.  It will normally be '/usr/local/share/man', but you should write it as '$(datarootdir)/man'.  (If you are using Autoconf, write it as '@mandir@'.)"
    },
    "man1dir": {
      "description": "The directory for installing section 1 man pages.  Write it as '$(mandir)/man1'."
    },
    "man2dir": {
      "description": "The directory for installing section 2 man pages.  Write it as '$(mandir)/man2'"
    },
    "...": {
      "description": "Use these names instead of 'manext' if the package needs to install man pages in more than one section of the manual."
    },
    "manext": {
      "description": "The file name extension for the installed man page.  This should contain a period followed by the appropriate digit; it should normally be '.1'."
    },
    "man1ext": {
      "description": "The file name extension for installed section 1 man pages."
    },
    "man2ext": {
      "description": "The file name extension for installed section 2 man pages."
    },
    "srcdir": {
      "description": "The directory for the sources being compiled.  The value of this variable is normally inserted by the 'configure' shell script.  (If you are using Autoconf, use 'srcdir = @srcdir@'.)"
    },
    "install-html": {
      "description": "```make\ninstall-html\ninstall-dvi\ninstall-pdf\ninstall-ps\n```\nThese targets install documentation in formats other than Info; they're intended to be called explicitly by the person installing the package, if that format is desired.  GNU prefers Info files, so these must be installed by the 'install' target. When you have many documentation files to install, we recommend that you avoid collisions and clutter by arranging for these targets to install in subdirectories of the appropriate installation directory, such as 'htmldir'.  As one example, if your package has multiple manuals, and you wish to install HTML documentation with many files (such as the \"split\" mode output by 'makeinfo --html'), you'll certainly want to use subdirectories, or two nodes with the same name in different manuals will overwrite each other. Please make these 'install-FORMAT' targets invoke the commands for the FORMAT target, for example, by making FORMAT a dependency."
    },
    "install-dvi": {
      "description": "```make\ninstall-html\ninstall-dvi\ninstall-pdf\ninstall-ps\n```\nThese targets install documentation in formats other than Info; they're intended to be called explicitly by the person installing the package, if that format is desired.  GNU prefers Info files, so these must be installed by the 'install' target. When you have many documentation files to install, we recommend that you avoid collisions and clutter by arranging for these targets to install in subdirectories of the appropriate installation directory, such as 'htmldir'.  As one example, if your package has multiple manuals, and you wish to install HTML documentation with many files (such as the \"split\" mode output by 'makeinfo --html'), you'll certainly want to use subdirectories, or two nodes with the same name in different manuals will overwrite each other. Please make these 'install-FORMAT' targets invoke the commands for the FORMAT target, for example, by making FORMAT a dependency."
    },
    "install-pdf": {
      "description": "```make\ninstall-html\ninstall-dvi\ninstall-pdf\ninstall-ps\n```\nThese targets install documentation in formats other than Info; they're intended to be called explicitly by the person installing the package, if that format is desired.  GNU prefers Info files, so these must be installed by the 'install' target. When you have many documentation files to install, we recommend that you avoid collisions and clutter by arranging for these targets to install in subdirectories of the appropriate installation directory, such as 'htmldir'.  As one example, if your package has multiple manuals, and you wish to install HTML documentation with many files (such as the \"split\" mode output by 'makeinfo --html'), you'll certainly want to use subdirectories, or two nodes with the same name in different manuals will overwrite each other. Please make these 'install-FORMAT' targets invoke the commands for the FORMAT target, for example, by making FORMAT a dependency."
    },
    "install-ps": {
      "description": "```make\ninstall-html\ninstall-dvi\ninstall-pdf\ninstall-ps\n```\nThese targets install documentation in formats other than Info; they're intended to be called explicitly by the person installing the package, if that format is desired.  GNU prefers Info files, so these must be installed by the 'install' target. When you have many documentation files to install, we recommend that you avoid collisions and clutter by arranging for these targets to install in subdirectories of the appropriate installation directory, such as 'htmldir'.  As one example, if your package has multiple manuals, and you wish to install HTML documentation with many files (such as the \"split\" mode output by 'makeinfo --html'), you'll certainly want to use subdirectories, or two nodes with the same name in different manuals will overwrite each other. Please make these 'install-FORMAT' targets invoke the commands for the FORMAT target, for example, by making FORMAT a dependency."
    },
    "uninstall": {
      "description": "Delete all the installed files--the copies that the 'install' and 'install-*' targets create. This rule should not modify the directories where compilation is done, only the directories where files are installed. The uninstallation commands are divided into three categories, just like the installation commands.  *Note Install Command Categories::."
    },
    "install-strip": {
      "description": "Like 'install', but strip the executable files while installing them.  In simple cases, this target can use the 'install' target in a simple way: install-strip: $(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \\ install But if the package installs scripts as well as real executables, the 'install-strip' target can't just refer to the 'install' target; it has to strip the executables but not the scripts. 'install-strip' should not strip the executables in the build directory which are being copied for installation.  It should only strip the copies that are installed. Normally we do not recommend stripping an executable unless you are sure the program has no bugs.  However, it can be reasonable to install a stripped executable for actual execution while saving the unstripped executable elsewhere in case there is a bug."
    },
    "maintainer-clean": {
      "description": "Delete almost everything that can be reconstructed with this Makefile.  This typically includes everything deleted by 'distclean', plus more: C source files produced by Bison, tags tables, Info files, and so on. The reason we say \"almost everything\" is that running the command 'make maintainer-clean' should not delete 'configure' even if 'configure' can be remade using a rule in the Makefile.  More generally, 'make maintainer-clean' should not delete anything that needs to exist in order to run 'configure' and then begin to build the program.  Also, there is no need to delete parent directories that were created with 'mkdir -p', since they could have existed anyway.  These are the only exceptions; 'maintainer-clean' should delete everything else that can be rebuilt. The 'maintainer-clean' target is intended to be used by a maintainer of the package, not by ordinary users.  You may need special tools to reconstruct some of the files that 'make maintainer-clean' deletes.  Since these files are normally included in the distribution, we don't take care to make them easy to reconstruct.  If you find you need to unpack the full distribution again, don't blame us. To help make users aware of this, the commands for the special 'maintainer-clean' target should start with these two: @echo 'This command is intended for maintainers to use; it' @echo 'deletes files that may need special tools to rebuild.'"
    },
    "info": {
      "description": "Generate any Info files needed.  The best way to write the rules is as follows: info: foo.info foo.info: foo.texi chap1.texi chap2.texi $(MAKEINFO) $(srcdir)/foo.texi You must define the variable 'MAKEINFO' in the Makefile.  It should run the 'makeinfo' program, which is part of the Texinfo distribution. Normally a GNU distribution comes with Info files, and that means the Info files are present in the source directory.  Therefore, the Make rule for an info file should update it in the source directory.  When users build the package, ordinarily Make will not update the Info files because they will already be up to date."
    },
    "dvi": {
      "description": "```make\ndvi\nhtml\npdf\nps\n```\nGenerate documentation files in the given format.  These targets should always exist, but any or all can be a no-op if the given output format cannot be generated.  These targets should not be dependencies of the 'all' target; the user must manually invoke them. Here's an example rule for generating DVI files from Texinfo: dvi: foo.dvi foo.dvi: foo.texi chap1.texi chap2.texi $(TEXI2DVI) $(srcdir)/foo.texi You must define the variable 'TEXI2DVI' in the Makefile.  It should run the program 'texi2dvi', which is part of the Texinfo distribution.  ('texi2dvi' uses TeX to do the real work of formatting.  TeX is not distributed with Texinfo.)  Alternatively, write only the dependencies, and allow GNU 'make' to provide the command. Here's another example, this one for generating HTML from Texinfo: html: foo.html foo.html: foo.texi chap1.texi chap2.texi $(TEXI2HTML) $(srcdir)/foo.texi Again, you would define the variable 'TEXI2HTML' in the Makefile; for example, it might run 'makeinfo --no-split --html' ('makeinfo' is part of the Texinfo distribution)."
    },
    "html": {
      "description": "```make\ndvi\nhtml\npdf\nps\n```\nGenerate documentation files in the given format.  These targets should always exist, but any or all can be a no-op if the given output format cannot be generated.  These targets should not be dependencies of the 'all' target; the user must manually invoke them. Here's an example rule for generating DVI files from Texinfo: dvi: foo.dvi foo.dvi: foo.texi chap1.texi chap2.texi $(TEXI2DVI) $(srcdir)/foo.texi You must define the variable 'TEXI2DVI' in the Makefile.  It should run the program 'texi2dvi', which is part of the Texinfo distribution.  ('texi2dvi' uses TeX to do the real work of formatting.  TeX is not distributed with Texinfo.)  Alternatively, write only the dependencies, and allow GNU 'make' to provide the command. Here's another example, this one for generating HTML from Texinfo: html: foo.html foo.html: foo.texi chap1.texi chap2.texi $(TEXI2HTML) $(srcdir)/foo.texi Again, you would define the variable 'TEXI2HTML' in the Makefile; for example, it might run 'makeinfo --no-split --html' ('makeinfo' is part of the Texinfo distribution)."
    },
    "pdf": {
      "description": "```make\ndvi\nhtml\npdf\nps\n```\nGenerate documentation files in the given format.  These targets should always exist, but any or all can be a no-op if the given output format cannot be generated.  These targets should not be dependencies of the 'all' target; the user must manually invoke them. Here's an example rule for generating DVI files from Texinfo: dvi: foo.dvi foo.dvi: foo.texi chap1.texi chap2.texi $(TEXI2DVI) $(srcdir)/foo.texi You must define the variable 'TEXI2DVI' in the Makefile.  It should run the program 'texi2dvi', which is part of the Texinfo distribution.  ('texi2dvi' uses TeX to do the real work of formatting.  TeX is not distributed with Texinfo.)  Alternatively, write only the dependencies, and allow GNU 'make' to provide the command. Here's another example, this one for generating HTML from Texinfo: html: foo.html foo.html: foo.texi chap1.texi chap2.texi $(TEXI2HTML) $(srcdir)/foo.texi Again, you would define the variable 'TEXI2HTML' in the Makefile; for example, it might run 'makeinfo --no-split --html' ('makeinfo' is part of the Texinfo distribution)."
    },
    "ps": {
      "description": "```make\ndvi\nhtml\npdf\nps\n```\nGenerate documentation files in the given format.  These targets should always exist, but any or all can be a no-op if the given output format cannot be generated.  These targets should not be dependencies of the 'all' target; the user must manually invoke them. Here's an example rule for generating DVI files from Texinfo: dvi: foo.dvi foo.dvi: foo.texi chap1.texi chap2.texi $(TEXI2DVI) $(srcdir)/foo.texi You must define the variable 'TEXI2DVI' in the Makefile.  It should run the program 'texi2dvi', which is part of the Texinfo distribution.  ('texi2dvi' uses TeX to do the real work of formatting.  TeX is not distributed with Texinfo.)  Alternatively, write only the dependencies, and allow GNU 'make' to provide the command. Here's another example, this one for generating HTML from Texinfo: html: foo.html foo.html: foo.texi chap1.texi chap2.texi $(TEXI2HTML) $(srcdir)/foo.texi Again, you would define the variable 'TEXI2HTML' in the Makefile; for example, it might run 'makeinfo --no-split --html' ('makeinfo' is part of the Texinfo distribution)."
    },
    "installcheck": {
      "description": "Perform installation tests (if any).  The user must build and install the program before running the tests.  You should not assume that '$(bindir)' is in the search path."
    },
    "installdirs": {
      "description": "It's useful to add a target named 'installdirs' to create the directories where files are installed, and their parent directories.  There is a script called 'mkinstalldirs' which is convenient for this; you can find it in the Gnulib package.  You can use a rule like this: # Make sure all installation directories (e.g. $(bindir)) # actually exist by making them if necessary. installdirs: mkinstalldirs $(srcdir)/mkinstalldirs $(bindir) $(datadir) \\ $(libdir) $(infodir) \\ $(mandir) or, if you wish to support 'DESTDIR' (strongly encouraged), # Make sure all installation directories (e.g. $(bindir)) # actually exist by making them if necessary. installdirs: mkinstalldirs $(srcdir)/mkinstalldirs \\ $(DESTDIR)$(bindir) $(DESTDIR)$(datadir) \\ $(DESTDIR)$(libdir) $(DESTDIR)$(infodir) \\ $(DESTDIR)$(mandir) This rule should not modify the directories where compilation is done.  It should do nothing but create installation directories."
    },
    "define": {
      "description": "```make\ndefine VARIABLE\ndefine VARIABLE =\ndefine VARIABLE :=\ndefine VARIABLE ::=\ndefine VARIABLE :::=\ndefine VARIABLE +=\ndefine VARIABLE ?=\nendef\n```\nDefine multi-line variables. *Note Multi-Line::."
    },
    "endef": {
      "description": "```make\ndefine VARIABLE\ndefine VARIABLE =\ndefine VARIABLE :=\ndefine VARIABLE ::=\ndefine VARIABLE :::=\ndefine VARIABLE +=\ndefine VARIABLE ?=\nendef\n```\nDefine multi-line variables. *Note Multi-Line::."
    },
    "undefine": {
      "description": "```make\nundefine VARIABLE\n```\nUndefining variables. *Note Undefine Directive::."
    },
    "ifdef": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "ifndef": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "ifeq": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "ifneq": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "else": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "endif": {
      "description": "```make\nifdef VARIABLE\nifndef VARIABLE\nifeq (A,B)\nifeq \"A\" \"B\"\nifeq 'A' 'B\nifneq (A,B)\nifneq \"A\" \"B\"\nifneq 'A' 'B\nelse\nendif\n```\nConditionally evaluate part of the makefile. *Note Conditionals::."
    },
    "include": {
      "description": "```make\ninclude FILE\n```\n"
    },
    "sinclude": {
      "description": "```make\nsinclude FILE\n```\nInclude another makefile. *Note Including Other Makefiles: Include."
    },
    "override": {
      "description": "```make\noverride VARIABLE-ASSIGNMENT\n```\nDefine a variable, overriding any previous definition, even one from the command line. *Note The 'override' Directive: Override Directive."
    },
    "export": {
      "description": "```make\nexport VARIABLE\nexport VARIABLE-ASSIGNMENT\nunexport VARIABLE\n```\nTell 'make' whether or not to export a particular variable to child processes. *Note Communicating Variables to a Sub-'make': Variables/Recursion."
    },
    "unexport": {
      "description": "```make\nexport VARIABLE\nexport VARIABLE-ASSIGNMENT\nunexport VARIABLE\n```\nTell 'make' whether or not to export a particular variable to child processes. *Note Communicating Variables to a Sub-'make': Variables/Recursion."
    },
    "private": {
      "description": "```make\nprivate VARIABLE-ASSIGNMENT\n```\nDo not allow this variable assignment to be inherited by prerequisites. *Note Suppressing Inheritance::."
    },
    "vpath": {
      "description": "Remove all search paths previously specified in any 'vpath' directive."
    },
    "subst": {
      "description": "```make\n$(subst FROM,TO,TEXT)\n```\nReplace FROM with TO in TEXT. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "patsubst": {
      "description": "```make\n$(patsubst PATTERN,REPLACEMENT,TEXT)\n```\nReplace words matching PATTERN with REPLACEMENT in TEXT. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "strip": {
      "description": "```make\n$(strip STRING)\n```\nRemove excess whitespace characters from STRING. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "findstring": {
      "description": "```make\n$(findstring FIND,TEXT)\n```\nLocate FIND in TEXT. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "filter": {
      "description": "```make\n$(filter PATTERN...,TEXT)\n```\nSelect words in TEXT that match one of the PATTERN words. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "filter-out": {
      "description": "```make\n$(filter-out PATTERN...,TEXT)\n```\nSelect words in TEXT that _do not_ match any of the PATTERN words. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "sort": {
      "description": "```make\n$(sort LIST)\n```\nSort the words in LIST lexicographically, removing duplicates. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "word": {
      "description": "```make\n$(word N,TEXT)\n```\nExtract the Nth word (one-origin) of TEXT. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "words": {
      "description": "```make\n$(words TEXT)\n```\nCount the number of words in TEXT. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "wordlist": {
      "description": "```make\n$(wordlist S,E,TEXT)\n```\nReturns the list of words in TEXT from S to E. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "firstword": {
      "description": "```make\n$(firstword NAMES...)\n```\nExtract the first word of NAMES. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "lastword": {
      "description": "```make\n$(lastword NAMES...)\n```\nExtract the last word of NAMES. *Note Functions for String Substitution and Analysis: Text Functions."
    },
    "dir": {
      "description": "```make\n$(dir NAMES...)\n```\nExtract the directory part of each file name. *Note Functions for File Names: File Name Functions."
    },
    "notdir": {
      "description": "```make\n$(notdir NAMES...)\n```\nExtract the non-directory part of each file name. *Note Functions for File Names: File Name Functions."
    },
    "suffix": {
      "description": "```make\n$(suffix NAMES...)\n```\nExtract the suffix (the last '.' and following characters) of each file name. *Note Functions for File Names: File Name Functions."
    },
    "basename": {
      "description": "```make\n$(basename NAMES...)\n```\nExtract the base name (name without suffix) of each file name. *Note Functions for File Names: File Name Functions."
    },
    "addsuffix": {
      "description": "```make\n$(addsuffix SUFFIX,NAMES...)\n```\nAppend SUFFIX to each word in NAMES. *Note Functions for File Names: File Name Functions."
    },
    "addprefix": {
      "description": "```make\n$(addprefix PREFIX,NAMES...)\n```\nPrepend PREFIX to each word in NAMES. *Note Functions for File Names: File Name Functions."
    },
    "join": {
      "description": "```make\n$(join LIST1,LIST2)\n```\nJoin two parallel lists of words. *Note Functions for File Names: File Name Functions."
    },
    "wildcard": {
      "description": "```make\n$(wildcard PATTERN...)\n```\nFind file names matching a shell file name pattern (_not_ a '%' pattern). *Note The Function 'wildcard': Wildcard Function."
    },
    "realpath": {
      "description": "```make\n$(realpath NAMES...)\n```\nFor each file name in NAMES, expand to an absolute name that does not contain any '.', '..', nor symlinks. *Note Functions for File Names: File Name Functions."
    },
    "abspath": {
      "description": "```make\n$(abspath NAMES...)\n```\nFor each file name in NAMES, expand to an absolute name that does not contain any '.' or '..' components, but preserves symlinks. *Note Functions for File Names: File Name Functions."
    },
    "error": {
      "description": "```make\n$(error TEXT...)\n```\nWhen this function is evaluated, 'make' generates a fatal error with the message TEXT. *Note Functions That Control Make: Make Control Functions."
    },
    "warning": {
      "description": "```make\n$(warning TEXT...)\n```\nWhen this function is evaluated, 'make' generates a warning with the message TEXT. *Note Functions That Control Make: Make Control Functions."
    },
    "shell": {
      "description": "```make\n$(shell COMMAND)\n```\nExecute a shell command and return its output. *Note The 'shell' Function: Shell Function."
    },
    "origin": {
      "description": "```make\n$(origin VARIABLE)\n```\nReturn a string describing how the 'make' variable VARIABLE was defined. *Note The 'origin' Function: Origin Function."
    },
    "flavor": {
      "description": "```make\n$(flavor VARIABLE)\n```\nReturn a string describing the flavor of the 'make' variable VARIABLE. *Note The 'flavor' Function: Flavor Function."
    },
    "let": {
      "description": "```make\n$(let VAR [VAR ...],WORDS,TEXT)\n```\nEvaluate TEXT with the VARs bound to the words in WORDS. *Note The 'let' Function: Let Function."
    },
    "foreach": {
      "description": "```make\n$(foreach VAR,WORDS,TEXT)\n```\nEvaluate TEXT with VAR bound to each word in WORDS, and concatenate the results. *Note The 'foreach' Function: Foreach Function."
    },
    "if": {
      "description": "```make\n$(if CONDITION,THEN-PART[,ELSE-PART])\n```\nEvaluate the condition CONDITION; if it's non-empty substitute the expansion of the THEN-PART otherwise substitute the expansion of the ELSE-PART. *Note Functions for Conditionals: Conditional Functions."
    },
    "or": {
      "description": "```make\n$(or CONDITION1[,CONDITION2[,CONDITION3...]])\n```\nEvaluate each condition CONDITIONN one at a time; substitute the first non-empty expansion.  If all expansions are empty, substitute the empty string. *Note Functions for Conditionals: Conditional Functions."
    },
    "and": {
      "description": "```make\n$(and CONDITION1[,CONDITION2[,CONDITION3...]])\n```\nEvaluate each condition CONDITIONN one at a time; if any expansion results in the empty string substitute the empty string.  If all expansions result in a non-empty string, substitute the expansion of the last CONDITION. *Note Functions for Conditionals: Conditional Functions."
    },
    "intcmp": {
      "description": "```make\n$(intcmp LHS,RHS[,LT-PART[,EQ-PART[,GT-PART]]])\n```\nCompare LHS and RHS numerically; substitute the expansion of LT-PART, EQ-PART, or GT-PART depending on whether the left-hand side is less-than, equal-to, or greater-than the right-hand side, respectively. *Note Functions for Conditionals: Conditional Functions."
    },
    "call": {
      "description": "```make\n$(call VAR,PARAM,...)\n```\nEvaluate the variable VAR replacing any references to '$(1)', '$(2)' with the first, second, etc. PARAM values. *Note The 'call' Function: Call Function."
    },
    "eval": {
      "description": "```make\n$(eval TEXT)\n```\nEvaluate TEXT then read the results as makefile commands.  Expands to the empty string. *Note The 'eval' Function: Eval Function."
    },
    "file": {
      "description": "```make\n$(file OP FILENAME,TEXT)\n```\nExpand the arguments, then open the file FILENAME using mode OP and write TEXT to that file. *Note The 'file' Function: File Function."
    },
    "value": {
      "description": "```make\n$(value VAR)\n```\nEvaluates to the contents of the variable VAR, with no expansion performed on it. *Note The 'value' Function: Value Function."
    },
    "MAKEFILES": {
      "description": "Makefiles to be read on every invocation of 'make'. *Note The Variable 'MAKEFILES': MAKEFILES Variable."
    },
    "VPATH": {
      "description": "Directory search path for files not found in the current directory. *Note 'VPATH' Search Path for All Prerequisites: General Search."
    },
    "SHELL": {
      "description": "The name of the system default command interpreter, usually '/bin/sh'.  You can set 'SHELL' in the makefile to change the shell used to run recipes.  *Note Recipe Execution: Execution.  The 'SHELL' variable is handled specially when importing from and exporting to the environment.  *Note Choosing the Shell::."
    },
    "MAKESHELL": {
      "description": "On MS-DOS only, the name of the command interpreter that is to be used by 'make'.  This value takes precedence over the value of 'SHELL'.  *Note MAKESHELL variable: Execution."
    },
    "MAKE": {
      "description": "The name with which 'make' was invoked.  Using this variable in recipes has special meaning.  *Note How the 'MAKE' Variable Works: MAKE Variable."
    },
    "MAKE_VERSION": {
      "description": "The built-in variable 'MAKE_VERSION' expands to the version number of the GNU 'make' program."
    },
    "MAKE_HOST": {
      "description": "The built-in variable 'MAKE_HOST' expands to a string representing the host that GNU 'make' was built to run on."
    },
    "MAKELEVEL": {
      "description": "The number of levels of recursion (sub-'make's). *Note Variables/Recursion::."
    },
    "MAKEFLAGS": {
      "description": "The flags given to 'make'.  You can set this in the environment or a makefile to set flags. *Note Communicating Options to a Sub-'make': Options/Recursion. It is _never_ appropriate to use 'MAKEFLAGS' directly in a recipe line: its contents may not be quoted correctly for use in the shell.  Always allow recursive 'make''s to obtain these values through the environment from its parent."
    },
    "GNUMAKEFLAGS": {
      "description": "Other flags parsed by 'make'.  You can set this in the environment or a makefile to set 'make' command-line flags.  GNU 'make' never sets this variable itself.  This variable is only needed if you'd like to set GNU 'make'-specific flags in a POSIX-compliant makefile.  This variable will be seen by GNU 'make' and ignored by other 'make' implementations.  It's not needed if you only use GNU 'make'; just use 'MAKEFLAGS' directly.  *Note Communicating Options to a Sub-'make': Options/Recursion."
    },
    "MAKECMDGOALS": {
      "description": "The targets given to 'make' on the command line.  Setting this variable has no effect on the operation of 'make'. *Note Arguments to Specify the Goals: Goals."
    },
    "CURDIR": {
      "description": "Set to the absolute pathname of the current working directory (after all '-C' options are processed, if any).  Setting this variable has no effect on the operation of 'make'. *Note Recursive Use of 'make': Recursion."
    },
    "SUFFIXES": {
      "description": "The default list of suffixes before 'make' reads any makefiles."
    },
    ".LIBPATTERNS": {
      "description": "Defines the naming of the libraries 'make' searches for, and their order. *Note Directory Search for Link Libraries: Libraries/Search."
    },
    "[FOO]": {
      "description": "```make\n[FOO] Error NN\n[FOO] SIGNAL DESCRIPTION\n```\nThese errors are not really 'make' errors at all.  They mean that a program that 'make' invoked as part of a recipe returned a non-0 error code ('Error NN'), which 'make' interprets as failure, or it exited in some other abnormal fashion (with a signal of some type). *Note Errors in Recipes: Errors. If no '***' is attached to the message, then the sub-process failed but the rule in the makefile was prefixed with the '-' special character, so 'make' ignored the error."
    },
    "missing": {
      "description": "```make\nmissing target pattern. Stop.\nmultiple target patterns. Stop.\ntarget pattern contains no `%'. Stop.\nmixed implicit and static pattern rules. Stop.\n```\nThese errors are generated for malformed static pattern rules (*note Syntax of Static Pattern Rules: Static Usage.).  The first means the target-pattern part of the rule is empty; the second means there are multiple pattern characters ('%') in the target-pattern part; the third means there are no pattern characters in the target-pattern part; and the fourth means that all three parts of the static pattern rule contain pattern characters ('%')-the first part should not contain pattern characters. If you see these errors and you aren't trying to create a static pattern rule, check the value of any variables in your target and prerequisite lists to be sure they do not contain colons."
    },
    "recipe": {
      "description": "```make\nrecipe commences before first target. Stop.\nmissing rule before recipe. Stop.\n```\nThis means the first thing in the makefile seems to be part of a recipe: it begins with a recipe prefix character and doesn't appear to be a legal 'make' directive (such as a variable assignment). Recipes must always be associated with a target. The second form is generated if the line has a semicolon as the first non-whitespace character; 'make' interprets this to mean you left out the \"target: prerequisite\" section of a rule.  *Note Rule Syntax::."
    },
    "No": {
      "description": "```make\nNo targets specified and no makefile found. Stop.\nNo targets. Stop.\n```\nThe former means that you didn't provide any targets to be built on the command line, and 'make' couldn't find any makefiles to read in.  The latter means that some makefile was found, but it didn't contain any default goal and none was given on the command line. GNU 'make' has nothing to do in these situations.  *Note Arguments to Specify the Makefile: Makefile Arguments."
    },
    "Makefile": {
      "description": "```make\nMakefile `XXX' was not found.\nIncluded makefile `XXX' was not found.\n```\nA makefile specified on the command line (first form) or included (second form) was not found."
    },
    "Included": {
      "description": "```make\nMakefile `XXX' was not found.\nIncluded makefile `XXX' was not found.\n```\nA makefile specified on the command line (first form) or included (second form) was not found."
    },
    "warning:": {
      "description": "```make\nwarning: ignoring prerequisites on suffix rule definition\n```\nAccording to POSIX, a suffix rule cannot contain prerequisites.  If a rule that could be a suffix rule has prerequisites it is interpreted as a simple explicit rule, with an odd target name. This requirement is obeyed when POSIX-conforming mode is enabled (the '.POSIX' target is defined).  In versions of GNU 'make' prior to 4.3, no warning was emitted and a suffix rule was created, however all prerequisites were ignored and were not part of the suffix rule.  Starting with GNU 'make' 4.3 the behavior is the same, and in addition this warning is generated.  In a future version the POSIX-conforming behavior will be the only behavior: no rule with a prerequisite can be suffix rule and this warning will be removed."
    },
    "Circular": {
      "description": "```make\nCircular XXX <- YYY dependency dropped.\n```\nThis means that 'make' detected a loop in the dependency graph: after tracing the prerequisite YYY of target XXX, and its prerequisites, etc., one of them depended on XXX again."
    },
    "Recursive": {
      "description": "```make\nRecursive variable `XXX' references itself (eventually). Stop.\n```\nThis means you've defined a normal (recursive) 'make' variable XXX that, when it's expanded, will refer to itself (XXX).  This is not allowed; either use simply-expanded variables (':=' or '::=') or use the append operator ('+=').  *Note How to Use Variables: Using Variables."
    },
    "Unterminated": {
      "description": "```make\nUnterminated variable reference. Stop.\n```\nThis means you forgot to provide the proper closing parenthesis or brace in your variable or function reference."
    },
    "insufficient": {
      "description": "```make\ninsufficient arguments to function `XXX'. Stop.\n```\nThis means you haven't provided the requisite number of arguments for this function.  See the documentation of the function for a description of its arguments.  *Note Functions for Transforming Text: Functions."
    },
    "multiple": {
      "description": "```make\nmissing target pattern. Stop.\nmultiple target patterns. Stop.\ntarget pattern contains no `%'. Stop.\nmixed implicit and static pattern rules. Stop.\n```\nThese errors are generated for malformed static pattern rules (*note Syntax of Static Pattern Rules: Static Usage.).  The first means the target-pattern part of the rule is empty; the second means there are multiple pattern characters ('%') in the target-pattern part; the third means there are no pattern characters in the target-pattern part; and the fourth means that all three parts of the static pattern rule contain pattern characters ('%')-the first part should not contain pattern characters. If you see these errors and you aren't trying to create a static pattern rule, check the value of any variables in your target and prerequisite lists to be sure they do not contain colons."
    },
    "target": {
      "description": "```make\nmissing target pattern. Stop.\nmultiple target patterns. Stop.\ntarget pattern contains no `%'. Stop.\nmixed implicit and static pattern rules. Stop.\n```\nThese errors are generated for malformed static pattern rules (*note Syntax of Static Pattern Rules: Static Usage.).  The first means the target-pattern part of the rule is empty; the second means there are multiple pattern characters ('%') in the target-pattern part; the third means there are no pattern characters in the target-pattern part; and the fourth means that all three parts of the static pattern rule contain pattern characters ('%')-the first part should not contain pattern characters. If you see these errors and you aren't trying to create a static pattern rule, check the value of any variables in your target and prerequisite lists to be sure they do not contain colons."
    },
    "mixed": {
      "description": "```make\nmissing target pattern. Stop.\nmultiple target patterns. Stop.\ntarget pattern contains no `%'. Stop.\nmixed implicit and static pattern rules. Stop.\n```\nThese errors are generated for malformed static pattern rules (*note Syntax of Static Pattern Rules: Static Usage.).  The first means the target-pattern part of the rule is empty; the second means there are multiple pattern characters ('%') in the target-pattern part; the third means there are no pattern characters in the target-pattern part; and the fourth means that all three parts of the static pattern rule contain pattern characters ('%')-the first part should not contain pattern characters. If you see these errors and you aren't trying to create a static pattern rule, check the value of any variables in your target and prerequisite lists to be sure they do not contain colons."
    }
  }
}
