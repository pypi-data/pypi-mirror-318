from datetime import date, datetime
from typing import List, Literal, Union, NewType

DateFormat = NewType("%d-%m-%Y" , str)

def get_new_holidays(mode : Literal['test', 'normal'] = ...) -> None: ...
def update_holiday(dates_set: Literal['holidays', 'exceptions'] = ...): ...
def workday(input_date: Union[DateFormat, date, datetime], direction: Literal['prev', 'next']) -> datetime: ...
def get_holidays_list(start_date: Union[DateFormat, date, datetime], end_date: Union[DateFormat, date, datetime]) -> List[datetime]: ...
def get_workdays_list(start_date: Union[DateFormat, date, datetime], end_date: Union[DateFormat, date, datetime]) -> List[datetime]: ...
def isHoliday(input_date: Union[DateFormat, date, datetime]) -> Union[bool, None]: ...
def month_last_weekday(input_date: Union[DateFormat, date, datetime], last_weekday: str, filtered: bool = ...) -> datetime: ...
def get_month_weekdays(input_date: Union[DateFormat, date, datetime], required_weekday: str, filtered: bool = ...) -> List[datetime]: ...
def get_weekdays(start_date: Union[DateFormat, date, datetime], end_date: Union[DateFormat, date, datetime], required_weekday: str, filtered: bool = ...) -> List[datetime]: ...

class __class__:
    def _CHUNK_SIZE (self, *args, **kwargs):
      '''None'''
    ...
    def _checkClosed (self, *args, **kwargs):
      '''None'''
    ...
    def _checkReadable (self, *args, **kwargs):
      '''None'''
    ...
    def _checkSeekable (self, *args, **kwargs):
      '''None'''
    ...
    def _checkWritable (self, *args, **kwargs):
      '''None'''
    ...
    def _finalizing (self, *args, **kwargs):
      '''None'''
    ...
    def buffer (self, *args, **kwargs):
      '''None'''
    ...
    def close (self, /):
      '''None'''
    ...
    def closed (self, *args, **kwargs):
      '''None'''
    ...
    def detach (self, /):
      '''None'''
    ...
    def encoding (self, *args, **kwargs):
      '''None'''
    ...
    def errors (self, *args, **kwargs):
      '''None'''
    ...
    def fileno (self, /):
      '''None'''
    ...
    def flush (self, /):
      '''None'''
    ...
    def isatty (self, /):
      '''None'''
    ...
    def line_buffering (self, *args, **kwargs):
      '''None'''
    ...
    def name (self, *args, **kwargs):
      '''None'''
    ...
    def newlines (self, *args, **kwargs):
      '''None'''
    ...
    def read (self, size=-1, /):
      '''None'''
    ...
    def readable (self, /):
      '''None'''
    ...
    def readline (self, size=-1, /):
      '''None'''
    ...
    def readlines (self, hint=-1, /):
      '''Return a list of lines from the stream.

hint can be specified to control the number of lines read: no more
lines will be read if the total size (in bytes/characters) of all
lines so far exceeds hint.'''
    ...
    def reconfigure (self, /, *, encoding=None, errors=None, newline=None, line_buffering=None, write_through=None):
      '''Reconfigure the text stream with new parameters.

This also does an implicit stream flush.'''
    ...
    def seek (self, cookie, whence=0, /):
      '''None'''
    ...
    def seekable (self, /):
      '''None'''
    ...
    def tell (self, /):
      '''None'''
    ...
    def truncate (self, pos=None, /):
      '''None'''
    ...
    def writable (self, /):
      '''None'''
    ...
    def write (self, text, /):
      '''None'''
    ...
    def write_through (self, *args, **kwargs):
      '''None'''
    ...
    def writelines (self, lines, /):
      '''Write a list of lines to stream.

Line separators are not added, so it is usual for each of the
lines provided to have a line separator at the end.'''
    ...