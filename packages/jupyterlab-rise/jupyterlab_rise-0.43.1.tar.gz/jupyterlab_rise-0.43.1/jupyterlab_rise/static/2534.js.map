{"version":3,"file":"2534.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/application/dist/index.es6.js"],"sourcesContent":["import { CommandRegistry } from '@lumino/commands';\nimport { PromiseDelegate, PluginRegistry } from '@lumino/coreutils';\nimport { ContextMenu, Widget } from '@lumino/widgets';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module application\n */\n/**\n * A class for creating pluggable applications.\n *\n * @typeParam T - The type of the application shell.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nclass Application {\n    /**\n     * Construct a new application.\n     *\n     * @param options - The options for creating the application.\n     */\n    constructor(options) {\n        var _a;\n        this._delegate = new PromiseDelegate();\n        this._started = false;\n        this._bubblingKeydown = false;\n        this.pluginRegistry =\n            (_a = options.pluginRegistry) !== null && _a !== void 0 ? _a : new PluginRegistry(options);\n        this.pluginRegistry.application = this;\n        // Initialize the application state.\n        this.commands = new CommandRegistry();\n        this.contextMenu = new ContextMenu({\n            commands: this.commands,\n            renderer: options.contextMenuRenderer\n        });\n        this.shell = options.shell;\n    }\n    /**\n     * The list of all the deferred plugins.\n     */\n    get deferredPlugins() {\n        return this.pluginRegistry.deferredPlugins;\n    }\n    /**\n     * A promise which resolves after the application has started.\n     *\n     * #### Notes\n     * This promise will resolve after the `start()` method is called,\n     * when all the bootstrapping and shell mounting work is complete.\n     */\n    get started() {\n        return this._delegate.promise;\n    }\n    /**\n     * Activate all the deferred plugins.\n     *\n     * @returns A promise which will resolve when each plugin is activated\n     * or rejects with an error if one cannot be activated.\n     */\n    async activateDeferredPlugins() {\n        await this.pluginRegistry.activatePlugins('defer');\n    }\n    /**\n     * Activate the plugin with the given ID.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns A promise which resolves when the plugin is activated\n     *   or rejects with an error if it cannot be activated.\n     */\n    async activatePlugin(id) {\n        return this.pluginRegistry.activatePlugin(id);\n    }\n    /**\n     * Deactivate the plugin and its downstream dependents if and only if the\n     * plugin and its dependents all support `deactivate`.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns A list of IDs of downstream plugins deactivated with this one.\n     */\n    async deactivatePlugin(id) {\n        return this.pluginRegistry.deactivatePlugin(id);\n    }\n    /**\n     * Deregister a plugin with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @param force - Whether to deregister the plugin even if it is active.\n     */\n    deregisterPlugin(id, force) {\n        this.pluginRegistry.deregisterPlugin(id, force);\n    }\n    /**\n     * Get a plugin description.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns The plugin description.\n     */\n    getPluginDescription(id) {\n        return this.pluginRegistry.getPluginDescription(id);\n    }\n    /**\n     * Test whether a plugin is registered with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns `true` if the plugin is registered, `false` otherwise.\n     */\n    hasPlugin(id) {\n        return this.pluginRegistry.hasPlugin(id);\n    }\n    /**\n     * Test whether a plugin is activated with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns `true` if the plugin is activated, `false` otherwise.\n     */\n    isPluginActivated(id) {\n        return this.pluginRegistry.isPluginActivated(id);\n    }\n    /**\n     * List the IDs of the plugins registered with the application.\n     *\n     * @returns A new array of the registered plugin IDs.\n     */\n    listPlugins() {\n        return this.pluginRegistry.listPlugins();\n    }\n    /**\n     * Register a plugin with the application.\n     *\n     * @param plugin - The plugin to register.\n     *\n     * #### Notes\n     * An error will be thrown if a plugin with the same ID is already\n     * registered, or if the plugin has a circular dependency.\n     *\n     * If the plugin provides a service which has already been provided\n     * by another plugin, the new service will override the old service.\n     */\n    registerPlugin(plugin) {\n        this.pluginRegistry.registerPlugin(plugin);\n    }\n    /**\n     * Register multiple plugins with the application.\n     *\n     * @param plugins - The plugins to register.\n     *\n     * #### Notes\n     * This calls `registerPlugin()` for each of the given plugins.\n     */\n    registerPlugins(plugins) {\n        this.pluginRegistry.registerPlugins(plugins);\n    }\n    /**\n     * Resolve an optional service of a given type.\n     *\n     * @param token - The token for the service type of interest.\n     *\n     * @returns A promise which resolves to an instance of the requested\n     *   service, or `null` if it cannot be resolved.\n     *\n     * #### Notes\n     * Services are singletons. The same instance will be returned each\n     * time a given service token is resolved.\n     *\n     * If the plugin which provides the service has not been activated,\n     * resolving the service will automatically activate the plugin.\n     *\n     * User code will not typically call this method directly. Instead,\n     * the optional services for the user's plugins will be resolved\n     * automatically when the plugin is activated.\n     */\n    async resolveOptionalService(token) {\n        return this.pluginRegistry.resolveOptionalService(token);\n    }\n    /**\n     * Resolve a required service of a given type.\n     *\n     * @param token - The token for the service type of interest.\n     *\n     * @returns A promise which resolves to an instance of the requested\n     *   service, or rejects with an error if it cannot be resolved.\n     *\n     * #### Notes\n     * Services are singletons. The same instance will be returned each\n     * time a given service token is resolved.\n     *\n     * If the plugin which provides the service has not been activated,\n     * resolving the service will automatically activate the plugin.\n     *\n     * User code will not typically call this method directly. Instead,\n     * the required services for the user's plugins will be resolved\n     * automatically when the plugin is activated.\n     */\n    async resolveRequiredService(token) {\n        return this.pluginRegistry.resolveRequiredService(token);\n    }\n    /**\n     * Start the application.\n     *\n     * @param options - The options for starting the application.\n     *\n     * @returns A promise which resolves when all bootstrapping work\n     *   is complete and the shell is mounted to the DOM.\n     *\n     * #### Notes\n     * This should be called once by the application creator after all\n     * initial plugins have been registered.\n     *\n     * If a plugin fails to the load, the error will be logged and the\n     * other valid plugins will continue to be loaded.\n     *\n     * Bootstrapping the application consists of the following steps:\n     * 1. Activate the startup plugins\n     * 2. Wait for those plugins to activate\n     * 3. Attach the shell widget to the DOM\n     * 4. Add the application event listeners\n     */\n    async start(options = {}) {\n        var _a, _b;\n        // Return immediately if the application is already started.\n        if (this._started) {\n            return this._delegate.promise;\n        }\n        // Mark the application as started;\n        this._started = true;\n        this._bubblingKeydown = (_a = options.bubblingKeydown) !== null && _a !== void 0 ? _a : false;\n        // Parse the host ID for attaching the shell.\n        const hostID = (_b = options.hostID) !== null && _b !== void 0 ? _b : '';\n        // Wait for the plugins to activate, then finalize startup.\n        await this.pluginRegistry.activatePlugins('startUp', options);\n        this.attachShell(hostID);\n        this.addEventListeners();\n        this._delegate.resolve();\n    }\n    /**\n     * Handle the DOM events for the application.\n     *\n     * @param event - The DOM event sent to the application.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events registered for the application. It\n     * should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'resize':\n                this.evtResize(event);\n                break;\n            case 'keydown':\n                this.evtKeydown(event);\n                break;\n            case 'keyup':\n                this.evtKeyup(event);\n                break;\n            case 'contextmenu':\n                this.evtContextMenu(event);\n                break;\n        }\n    }\n    /**\n     * Attach the application shell to the DOM.\n     *\n     * @param id - The ID of the host node for the shell, or `''`.\n     *\n     * #### Notes\n     * If the ID is not provided, the document body will be the host.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    attachShell(id) {\n        Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);\n    }\n    /**\n     * Add the application event listeners.\n     *\n     * #### Notes\n     * The default implementation of this method adds listeners for\n     * `'keydown'` and `'resize'` events.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    addEventListeners() {\n        document.addEventListener('contextmenu', this);\n        document.addEventListener('keydown', this, !this._bubblingKeydown);\n        document.addEventListener('keyup', this, !this._bubblingKeydown);\n        window.addEventListener('resize', this);\n    }\n    /**\n     * A method invoked on a document `'keydown'` event.\n     *\n     * #### Notes\n     * The default implementation of this method invokes the key down\n     * processing method of the application command registry.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtKeydown(event) {\n        this.commands.processKeydownEvent(event);\n    }\n    /**\n     * A method invoked on a document `'keyup'` event.\n     *\n     * #### Notes\n     * The default implementation of this method invokes the key up\n     * processing method of the application command registry.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtKeyup(event) {\n        this.commands.processKeyupEvent(event);\n    }\n    /**\n     * A method invoked on a document `'contextmenu'` event.\n     *\n     * #### Notes\n     * The default implementation of this method opens the application\n     * `contextMenu` at the current mouse position.\n     *\n     * If the application context menu has no matching content *or* if\n     * the shift key is pressed, the default browser context menu will\n     * be opened instead.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtContextMenu(event) {\n        if (event.shiftKey) {\n            return;\n        }\n        if (this.contextMenu.open(event)) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * A method invoked on a window `'resize'` event.\n     *\n     * #### Notes\n     * The default implementation of this method updates the shell.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtResize(event) {\n        this.shell.update();\n    }\n}\n\nexport { Application };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Application","constructor","options","_a","this","_delegate","PromiseDelegate","_started","_bubblingKeydown","pluginRegistry","PluginRegistry","application","commands","CommandRegistry","contextMenu","ContextMenu","renderer","contextMenuRenderer","shell","deferredPlugins","started","promise","activateDeferredPlugins","activatePlugins","activatePlugin","id","deactivatePlugin","deregisterPlugin","force","getPluginDescription","hasPlugin","isPluginActivated","listPlugins","registerPlugin","plugin","registerPlugins","plugins","resolveOptionalService","token","resolveRequiredService","start","_b","bubblingKeydown","hostID","attachShell","addEventListeners","resolve","handleEvent","event","type","evtResize","evtKeydown","evtKeyup","evtContextMenu","Widget","attach","document","getElementById","body","addEventListener","window","processKeydownEvent","processKeyupEvent","shiftKey","open","preventDefault","stopPropagation","update"],"sourceRoot":""}