{"version":3,"file":"1806.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/collections/dist/index.es6.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/messaging/dist/index.es6.js"],"sourcesContent":["/**\n * A generic doubly-linked list.\n */\nclass LinkedList {\n    constructor() {\n        this._first = null;\n        this._last = null;\n        this._size = 0;\n    }\n    /**\n     * Whether the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get isEmpty() {\n        return this._size === 0;\n    }\n    /**\n     * The size of the list.\n     *\n     * #### Complexity\n     * `O(1)`\n     *\n     * #### Notes\n     * This is equivalent to `length`.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The length of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `size`.\n     *\n     * This property is deprecated.\n     */\n    get length() {\n        return this._size;\n    }\n    /**\n     * The first value in the list.\n     *\n     * This is `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get first() {\n        return this._first ? this._first.value : undefined;\n    }\n    /**\n     * The last value in the list.\n     *\n     * This is `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get last() {\n        return this._last ? this._last.value : undefined;\n    }\n    /**\n     * The first node in the list.\n     *\n     * This is `null` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get firstNode() {\n        return this._first;\n    }\n    /**\n     * The last node in the list.\n     *\n     * This is `null` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    get lastNode() {\n        return this._last;\n    }\n    /**\n     * Create an iterator over the values in the list.\n     *\n     * @returns A new iterator starting with the first value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node) {\n            yield node.value;\n            node = node.next;\n        }\n    }\n    /**\n     * Create a reverse iterator over the values in the list.\n     *\n     * @returns A new iterator starting with the last value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    *retro() {\n        let node = this._last;\n        while (node) {\n            yield node.value;\n            node = node.prev;\n        }\n    }\n    /**\n     * Create an iterator over the nodes in the list.\n     *\n     * @returns A new iterator starting with the first node.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    *nodes() {\n        let node = this._first;\n        while (node) {\n            yield node;\n            node = node.next;\n        }\n    }\n    /**\n     * Create a reverse iterator over the nodes in the list.\n     *\n     * @returns A new iterator starting with the last node.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    *retroNodes() {\n        let node = this._last;\n        while (node) {\n            yield node;\n            node = node.prev;\n        }\n    }\n    /**\n     * Assign new values to the list, replacing all current values.\n     *\n     * @param values - The values to assign to the list.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    assign(values) {\n        this.clear();\n        for (const value of values) {\n            this.addLast(value);\n        }\n    }\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `addLast`.\n     */\n    push(value) {\n        this.addLast(value);\n    }\n    /**\n     * Remove and return the value at the end of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `removeLast`.\n     */\n    pop() {\n        return this.removeLast();\n    }\n    /**\n     * Add a value to the beginning of the list.\n     *\n     * @param value - The value to add to the beginning of the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `addFirst`.\n     */\n    shift(value) {\n        this.addFirst(value);\n    }\n    /**\n     * Remove and return the value at the beginning of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * This is equivalent to `removeFirst`.\n     */\n    unshift() {\n        return this.removeFirst();\n    }\n    /**\n     * Add a value to the beginning of the list.\n     *\n     * @param value - The value to add to the beginning of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    addFirst(value) {\n        let node = new Private.LinkedListNode(this, value);\n        if (!this._first) {\n            this._first = node;\n            this._last = node;\n        }\n        else {\n            node.next = this._first;\n            this._first.prev = node;\n            this._first = node;\n        }\n        this._size++;\n        return node;\n    }\n    /**\n     * Add a value to the end of the list.\n     *\n     * @param value - The value to add to the end of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    addLast(value) {\n        let node = new Private.LinkedListNode(this, value);\n        if (!this._last) {\n            this._first = node;\n            this._last = node;\n        }\n        else {\n            node.prev = this._last;\n            this._last.next = node;\n            this._last = node;\n        }\n        this._size++;\n        return node;\n    }\n    /**\n     * Insert a value before a specific node in the list.\n     *\n     * @param value - The value to insert before the reference node.\n     *\n     * @param ref - The reference node of interest. If this is `null`,\n     *   the value will be added to the beginning of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Notes\n     * The reference node must be owned by the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    insertBefore(value, ref) {\n        if (!ref || ref === this._first) {\n            return this.addFirst(value);\n        }\n        if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n            throw new Error('Reference node is not owned by the list.');\n        }\n        let node = new Private.LinkedListNode(this, value);\n        let _ref = ref;\n        let prev = _ref.prev;\n        node.next = _ref;\n        node.prev = prev;\n        _ref.prev = node;\n        prev.next = node;\n        this._size++;\n        return node;\n    }\n    /**\n     * Insert a value after a specific node in the list.\n     *\n     * @param value - The value to insert after the reference node.\n     *\n     * @param ref - The reference node of interest. If this is `null`,\n     *   the value will be added to the end of the list.\n     *\n     * @returns The list node which holds the value.\n     *\n     * #### Notes\n     * The reference node must be owned by the list.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    insertAfter(value, ref) {\n        if (!ref || ref === this._last) {\n            return this.addLast(value);\n        }\n        if (!(ref instanceof Private.LinkedListNode) || ref.list !== this) {\n            throw new Error('Reference node is not owned by the list.');\n        }\n        let node = new Private.LinkedListNode(this, value);\n        let _ref = ref;\n        let next = _ref.next;\n        node.next = next;\n        node.prev = _ref;\n        _ref.next = node;\n        next.prev = node;\n        this._size++;\n        return node;\n    }\n    /**\n     * Remove and return the value at the beginning of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    removeFirst() {\n        let node = this._first;\n        if (!node) {\n            return undefined;\n        }\n        if (node === this._last) {\n            this._first = null;\n            this._last = null;\n        }\n        else {\n            this._first = node.next;\n            this._first.prev = null;\n        }\n        node.list = null;\n        node.next = null;\n        node.prev = null;\n        this._size--;\n        return node.value;\n    }\n    /**\n     * Remove and return the value at the end of the list.\n     *\n     * @returns The removed value, or `undefined` if the list is empty.\n     *\n     * #### Complexity\n     * Constant.\n     */\n    removeLast() {\n        let node = this._last;\n        if (!node) {\n            return undefined;\n        }\n        if (node === this._first) {\n            this._first = null;\n            this._last = null;\n        }\n        else {\n            this._last = node.prev;\n            this._last.next = null;\n        }\n        node.list = null;\n        node.next = null;\n        node.prev = null;\n        this._size--;\n        return node.value;\n    }\n    /**\n     * Remove a specific node from the list.\n     *\n     * @param node - The node to remove from the list.\n     *\n     * #### Complexity\n     * Constant.\n     *\n     * #### Notes\n     * The node must be owned by the list.\n     */\n    removeNode(node) {\n        if (!(node instanceof Private.LinkedListNode) || node.list !== this) {\n            throw new Error('Node is not owned by the list.');\n        }\n        let _node = node;\n        if (_node === this._first && _node === this._last) {\n            this._first = null;\n            this._last = null;\n        }\n        else if (_node === this._first) {\n            this._first = _node.next;\n            this._first.prev = null;\n        }\n        else if (_node === this._last) {\n            this._last = _node.prev;\n            this._last.next = null;\n        }\n        else {\n            _node.next.prev = _node.prev;\n            _node.prev.next = _node.next;\n        }\n        _node.list = null;\n        _node.next = null;\n        _node.prev = null;\n        this._size--;\n    }\n    /**\n     * Remove all values from the list.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    clear() {\n        let node = this._first;\n        while (node) {\n            let next = node.next;\n            node.list = null;\n            node.prev = null;\n            node.next = null;\n            node = next;\n        }\n        this._first = null;\n        this._last = null;\n        this._size = 0;\n    }\n}\n/**\n * The namespace for the `LinkedList` class statics.\n */\n(function (LinkedList) {\n    /**\n     * Create a linked list from an iterable of values.\n     *\n     * @param values - The iterable object of interest.\n     *\n     * @returns A new linked list initialized with the given values.\n     *\n     * #### Complexity\n     * Linear.\n     */\n    function from(values) {\n        let list = new LinkedList();\n        list.assign(values);\n        return list;\n    }\n    LinkedList.from = from;\n})(LinkedList || (LinkedList = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The internal linked list node implementation.\n     */\n    class LinkedListNode {\n        /**\n         * Construct a new linked list node.\n         *\n         * @param list - The list which owns the node.\n         *\n         * @param value - The value for the link.\n         */\n        constructor(list, value) {\n            /**\n             * The linked list which created and owns the node.\n             */\n            this.list = null;\n            /**\n             * The next node in the list.\n             */\n            this.next = null;\n            /**\n             * The previous node in the list.\n             */\n            this.prev = null;\n            this.list = list;\n            this.value = value;\n        }\n    }\n    Private.LinkedListNode = LinkedListNode;\n})(Private || (Private = {}));\n\nexport { LinkedList };\n//# sourceMappingURL=index.es6.js.map\n","import { every, retro, some, ArrayExt } from '@lumino/algorithm';\nimport { LinkedList } from '@lumino/collections';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module messaging\n */\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nclass Message {\n    /**\n     * Construct a new message.\n     *\n     * @param type - The type of the message.\n     */\n    constructor(type) {\n        this.type = type;\n    }\n    /**\n     * Test whether the message is conflatable.\n     *\n     * #### Notes\n     * Message conflation is an advanced topic. Most message types will\n     * not make use of this feature.\n     *\n     * If a conflatable message is posted to a handler while another\n     * conflatable message of the same `type` has already been posted\n     * to the handler, the `conflate()` method of the existing message\n     * will be invoked. If that method returns `true`, the new message\n     * will not be enqueued. This allows messages to be compressed, so\n     * that only a single instance of the message type is processed per\n     * cycle, no matter how many times messages of that type are posted.\n     *\n     * Custom message types may reimplement this property.\n     *\n     * The default implementation is always `false`.\n     */\n    get isConflatable() {\n        return false;\n    }\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * @param other - A conflatable message of the same `type`.\n     *\n     * @returns `true` if the message was successfully conflated, or\n     *   `false` otherwise.\n     *\n     * #### Notes\n     * Message conflation is an advanced topic. Most message types will\n     * not make use of this feature.\n     *\n     * This method is called automatically by the message loop when the\n     * given message is posted to the handler paired with this message.\n     * This message will already be enqueued and conflatable, and the\n     * given message will have the same `type` and also be conflatable.\n     *\n     * This method should merge the state of the other message into this\n     * message as needed so that when this message is finally delivered\n     * to the handler, it receives the most up-to-date information.\n     *\n     * If this method returns `true`, it signals that the other message\n     * was successfully conflated and that message will not be enqueued.\n     *\n     * If this method returns `false`, the other message will be enqueued\n     * for normal delivery.\n     *\n     * Custom message types may reimplement this method.\n     *\n     * The default implementation always returns `false`.\n     */\n    conflate(other) {\n        return false;\n    }\n}\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nclass ConflatableMessage extends Message {\n    /**\n     * Test whether the message is conflatable.\n     *\n     * #### Notes\n     * This property is always `true`.\n     */\n    get isConflatable() {\n        return true;\n    }\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * #### Notes\n     * This method always returns `true`.\n     */\n    conflate(other) {\n        return true;\n    }\n}\n/**\n * The namespace for the global singleton message loop.\n */\nvar MessageLoop;\n(function (MessageLoop) {\n    /**\n     * A function that cancels the pending loop task; `null` if unavailable.\n     */\n    let pending = null;\n    /**\n     * Schedules a function for invocation as soon as possible asynchronously.\n     *\n     * @param fn The function to invoke when called back.\n     *\n     * @returns An anonymous function that will unschedule invocation if possible.\n     */\n    const schedule = (resolved => (fn) => {\n        let rejected = false;\n        resolved.then(() => !rejected && fn());\n        return () => {\n            rejected = true;\n        };\n    })(Promise.resolve());\n    /**\n     * Send a message to a message handler to process immediately.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to deliver to the handler.\n     *\n     * #### Notes\n     * The message will first be sent through any installed message hooks\n     * for the handler. If the message passes all hooks, it will then be\n     * delivered to the `processMessage` method of the handler.\n     *\n     * The message will not be conflated with pending posted messages.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function sendMessage(handler, msg) {\n        // Lookup the message hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Handle the common case of no installed hooks.\n        if (!hooks || hooks.length === 0) {\n            invokeHandler(handler, msg);\n            return;\n        }\n        // Invoke the message hooks starting with the newest first.\n        let passed = every(retro(hooks), hook => {\n            return hook ? invokeHook(hook, handler, msg) : true;\n        });\n        // Invoke the handler if the message passes all hooks.\n        if (passed) {\n            invokeHandler(handler, msg);\n        }\n    }\n    MessageLoop.sendMessage = sendMessage;\n    /**\n     * Post a message to a message handler to process in the future.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to post to the handler.\n     *\n     * #### Notes\n     * The message will be conflated with the pending posted messages for\n     * the handler, if possible. If the message is not conflated, it will\n     * be queued for normal delivery on the next cycle of the event loop.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function postMessage(handler, msg) {\n        // Handle the common case of a non-conflatable message.\n        if (!msg.isConflatable) {\n            enqueueMessage(handler, msg);\n            return;\n        }\n        // Conflate the message with an existing message if possible.\n        let conflated = some(messageQueue, posted => {\n            if (posted.handler !== handler) {\n                return false;\n            }\n            if (!posted.msg) {\n                return false;\n            }\n            if (posted.msg.type !== msg.type) {\n                return false;\n            }\n            if (!posted.msg.isConflatable) {\n                return false;\n            }\n            return posted.msg.conflate(msg);\n        });\n        // Enqueue the message if it was not conflated.\n        if (!conflated) {\n            enqueueMessage(handler, msg);\n        }\n    }\n    MessageLoop.postMessage = postMessage;\n    /**\n     * Install a message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to install.\n     *\n     * #### Notes\n     * A message hook is invoked before a message is delivered to the\n     * handler. If the hook returns `false`, no other hooks will be\n     * invoked and the message will not be delivered to the handler.\n     *\n     * The most recently installed message hook is executed first.\n     *\n     * If the hook is already installed, this is a no-op.\n     */\n    function installMessageHook(handler, hook) {\n        // Look up the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Bail early if the hook is already installed.\n        if (hooks && hooks.indexOf(hook) !== -1) {\n            return;\n        }\n        // Add the hook to the end, so it will be the first to execute.\n        if (!hooks) {\n            messageHooks.set(handler, [hook]);\n        }\n        else {\n            hooks.push(hook);\n        }\n    }\n    MessageLoop.installMessageHook = installMessageHook;\n    /**\n     * Remove an installed message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to remove.\n     *\n     * #### Notes\n     * It is safe to call this function while the hook is executing.\n     *\n     * If the hook is not installed, this is a no-op.\n     */\n    function removeMessageHook(handler, hook) {\n        // Lookup the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Bail early if the hooks do not exist.\n        if (!hooks) {\n            return;\n        }\n        // Lookup the index of the hook and bail if not found.\n        let i = hooks.indexOf(hook);\n        if (i === -1) {\n            return;\n        }\n        // Clear the hook and schedule a cleanup of the array.\n        hooks[i] = null;\n        scheduleCleanup(hooks);\n    }\n    MessageLoop.removeMessageHook = removeMessageHook;\n    /**\n     * Clear all message data associated with a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * #### Notes\n     * This will clear all posted messages and hooks for the handler.\n     */\n    function clearData(handler) {\n        // Lookup the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Clear all messsage hooks for the handler.\n        if (hooks && hooks.length > 0) {\n            ArrayExt.fill(hooks, null);\n            scheduleCleanup(hooks);\n        }\n        // Clear all posted messages for the handler.\n        for (const posted of messageQueue) {\n            if (posted.handler === handler) {\n                posted.handler = null;\n                posted.msg = null;\n            }\n        }\n    }\n    MessageLoop.clearData = clearData;\n    /**\n     * Process the pending posted messages in the queue immediately.\n     *\n     * #### Notes\n     * This function is useful when posted messages must be processed immediately.\n     *\n     * This function should normally not be needed, but it may be\n     * required to work around certain browser idiosyncrasies.\n     *\n     * Recursing into this function is a no-op.\n     */\n    function flush() {\n        // Bail if recursion is detected or if there is no pending task.\n        if (flushGuard || pending === null) {\n            return;\n        }\n        // Unschedule the pending loop task.\n        pending();\n        pending = null;\n        // Run the message loop within the recursion guard.\n        flushGuard = true;\n        runMessageLoop();\n        flushGuard = false;\n    }\n    MessageLoop.flush = flush;\n    /**\n     * Get the message loop exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return exceptionHandler;\n    }\n    MessageLoop.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the message loop exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a message handler or a\n     * message hook throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        let old = exceptionHandler;\n        exceptionHandler = handler;\n        return old;\n    }\n    MessageLoop.setExceptionHandler = setExceptionHandler;\n    /**\n     * The queue of posted message pairs.\n     */\n    const messageQueue = new LinkedList();\n    /**\n     * A mapping of handler to array of installed message hooks.\n     */\n    const messageHooks = new WeakMap();\n    /**\n     * A set of message hook arrays which are pending cleanup.\n     */\n    const dirtySet = new Set();\n    /**\n     * The message loop exception handler.\n     */\n    let exceptionHandler = (err) => {\n        console.error(err);\n    };\n    /**\n     * A guard flag to prevent flush recursion.\n     */\n    let flushGuard = false;\n    /**\n     * Invoke a message hook with the specified handler and message.\n     *\n     * Returns the result of the hook, or `true` if the hook throws.\n     *\n     * Exceptions in the hook will be caught and logged.\n     */\n    function invokeHook(hook, handler, msg) {\n        let result = true;\n        try {\n            if (typeof hook === 'function') {\n                result = hook(handler, msg);\n            }\n            else {\n                result = hook.messageHook(handler, msg);\n            }\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n        return result;\n    }\n    /**\n     * Invoke a message handler with the specified message.\n     *\n     * Exceptions in the handler will be caught and logged.\n     */\n    function invokeHandler(handler, msg) {\n        try {\n            handler.processMessage(msg);\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n    }\n    /**\n     * Add a message to the end of the message queue.\n     *\n     * This will automatically schedule a run of the message loop.\n     */\n    function enqueueMessage(handler, msg) {\n        // Add the posted message to the queue.\n        messageQueue.addLast({ handler, msg });\n        // Bail if a loop task is already pending.\n        if (pending !== null) {\n            return;\n        }\n        // Schedule a run of the message loop.\n        pending = schedule(runMessageLoop);\n    }\n    /**\n     * Run an iteration of the message loop.\n     *\n     * This will process all pending messages in the queue. If a message\n     * is added to the queue while the message loop is running, it will\n     * be processed on the next cycle of the loop.\n     */\n    function runMessageLoop() {\n        // Clear the task so the next loop can be scheduled.\n        pending = null;\n        // If the message queue is empty, there is nothing else to do.\n        if (messageQueue.isEmpty) {\n            return;\n        }\n        // Add a sentinel value to the end of the queue. The queue will\n        // only be processed up to the sentinel. Messages posted during\n        // this cycle will execute on the next cycle.\n        let sentinel = { handler: null, msg: null };\n        messageQueue.addLast(sentinel);\n        // Enter the message loop.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // Remove the first posted message in the queue.\n            let posted = messageQueue.removeFirst();\n            // If the value is the sentinel, exit the loop.\n            if (posted === sentinel) {\n                return;\n            }\n            // Dispatch the message if it has not been cleared.\n            if (posted.handler && posted.msg) {\n                sendMessage(posted.handler, posted.msg);\n            }\n        }\n    }\n    /**\n     * Schedule a cleanup of a message hooks array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any `null` hook will\n     * be removed from the array.\n     */\n    function scheduleCleanup(hooks) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(hooks);\n    }\n    /**\n     * Cleanup the message hook arrays in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupHooks);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty hooks in a message hooks array.\n     *\n     * This will remove any `null` hook from the array.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupHooks(hooks) {\n        ArrayExt.removeAllWhere(hooks, isNull);\n    }\n    /**\n     * Test whether a value is `null`.\n     */\n    function isNull(value) {\n        return value === null;\n    }\n})(MessageLoop || (MessageLoop = {}));\n\nexport { ConflatableMessage, Message, MessageLoop };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Private","MessageLoop","LinkedList","constructor","this","_first","_last","_size","isEmpty","size","length","first","value","undefined","last","firstNode","lastNode","Symbol","iterator","node","next","retro","prev","nodes","retroNodes","assign","values","clear","addLast","push","pop","removeLast","shift","addFirst","unshift","removeFirst","LinkedListNode","insertBefore","ref","list","Error","_ref","insertAfter","removeNode","_node","from","Message","type","isConflatable","conflate","other","ConflatableMessage","pending","schedule","resolved","Promise","resolve","fn","rejected","then","sendMessage","handler","msg","hooks","messageHooks","get","invokeHandler","passed","every","hook","result","messageHook","err","exceptionHandler","invokeHook","postMessage","some","messageQueue","posted","enqueueMessage","installMessageHook","indexOf","set","removeMessageHook","i","scheduleCleanup","clearData","ArrayExt","fill","flush","flushGuard","runMessageLoop","getExceptionHandler","setExceptionHandler","old","WeakMap","dirtySet","Set","console","error","processMessage","sentinel","cleanupDirtySet","add","forEach","cleanupHooks","removeAllWhere","isNull"],"sourceRoot":""}