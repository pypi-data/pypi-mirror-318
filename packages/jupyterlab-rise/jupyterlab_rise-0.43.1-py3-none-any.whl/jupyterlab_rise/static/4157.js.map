{"version":3,"file":"4157.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/polling/dist/index.es6.js"],"sourcesContent":["import { PromiseDelegate, JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A class that wraps an asynchronous function to poll at a regular interval\n * with exponential increases to the interval length if the poll fails.\n *\n * @typeparam T - The resolved type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam U - The rejected type of the factory's promises.\n * Defaults to `any`.\n *\n * @typeparam V - An optional type to extend the phases supported by a poll.\n * Defaults to `standby`, which already exists in the `Phase` type.\n */\nclass Poll {\n    /**\n     * Instantiate a new poll with exponential backoff in case of failure.\n     *\n     * @param options - The poll instantiation options.\n     */\n    constructor(options) {\n        var _a;\n        this._disposed = new Signal(this);\n        this._lingered = 0;\n        this._tick = new PromiseDelegate();\n        this._ticked = new Signal(this);\n        this._factory = options.factory;\n        this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private.DEFAULT_LINGER;\n        this._standby = options.standby || Private.DEFAULT_STANDBY;\n        this._state = { ...Private.DEFAULT_STATE, timestamp: new Date().getTime() };\n        // Normalize poll frequency `max` to be the greater of\n        // default `max`, `options.frequency.max`, or `options.frequency.interval`.\n        const frequency = options.frequency || {};\n        const max = Math.max(frequency.interval || 0, frequency.max || 0, Private.DEFAULT_FREQUENCY.max);\n        this.frequency = { ...Private.DEFAULT_FREQUENCY, ...frequency, ...{ max } };\n        this.name = options.name || Private.DEFAULT_NAME;\n        if ('auto' in options ? options.auto : true) {\n            setTimeout(() => this.start());\n        }\n    }\n    /**\n     * A signal emitted when the poll is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * The polling frequency parameters.\n     */\n    get frequency() {\n        return this._frequency;\n    }\n    set frequency(frequency) {\n        if (this.isDisposed || JSONExt.deepEqual(frequency, this.frequency || {})) {\n            return;\n        }\n        let { backoff, interval, max } = frequency;\n        interval = Math.round(interval);\n        max = Math.round(max);\n        if (typeof backoff === 'number' && backoff < 1) {\n            throw new Error('Poll backoff growth factor must be at least 1');\n        }\n        if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {\n            throw new Error('Poll interval must be between 0 and max');\n        }\n        if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {\n            throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);\n        }\n        this._frequency = { backoff, interval, max };\n    }\n    /**\n     * Whether the poll is disposed.\n     */\n    get isDisposed() {\n        return this.state.phase === 'disposed';\n    }\n    /**\n     * Indicates when the poll switches to standby.\n     */\n    get standby() {\n        return this._standby;\n    }\n    set standby(standby) {\n        if (this.isDisposed || this.standby === standby) {\n            return;\n        }\n        this._standby = standby;\n    }\n    /**\n     * The poll state, which is the content of the current poll tick.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * A promise that resolves when the poll next ticks.\n     */\n    get tick() {\n        return this._tick.promise;\n    }\n    /**\n     * A signal emitted when the poll ticks and fires off a new request.\n     */\n    get ticked() {\n        return this._ticked;\n    }\n    /**\n     * Return an async iterator that yields every tick.\n     */\n    async *[Symbol.asyncIterator]() {\n        while (!this.isDisposed) {\n            yield this.state;\n            await this.tick.catch(() => undefined);\n        }\n    }\n    /**\n     * Dispose the poll.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._state = {\n            ...Private.DISPOSED_STATE,\n            timestamp: new Date().getTime()\n        };\n        this._tick.promise.catch(_ => undefined);\n        this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));\n        this._disposed.emit(undefined);\n        Signal.clearData(this);\n    }\n    /**\n     * Refreshes the poll. Schedules `refreshed` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     *\n     * #### Notes\n     * The returned promise resolves after the tick is scheduled, but before\n     * the polling action is run. To wait until after the poll action executes,\n     * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`\n     */\n    refresh() {\n        return this.schedule({\n            cancel: ({ phase }) => phase === 'refreshed',\n            interval: Poll.IMMEDIATE,\n            phase: 'refreshed'\n        });\n    }\n    /**\n     * Schedule the next poll tick.\n     *\n     * @param next - The next poll state data to schedule. Defaults to standby.\n     *\n     * @param next.cancel - Cancels state transition if function returns `true`.\n     *\n     * @returns A promise that resolves when the next poll state is active.\n     *\n     * #### Notes\n     * This method is not meant to be invoked by user code typically. It is public\n     * to allow poll instances to be composed into classes that schedule ticks.\n     */\n    async schedule(next = {}) {\n        if (this.isDisposed) {\n            return;\n        }\n        // Check if the phase transition should be canceled.\n        if (next.cancel && next.cancel(this.state)) {\n            return;\n        }\n        // Update poll state.\n        const pending = this._tick;\n        const scheduled = new PromiseDelegate();\n        const state = {\n            interval: this.frequency.interval,\n            payload: null,\n            phase: 'standby',\n            timestamp: new Date().getTime(),\n            ...next\n        };\n        this._state = state;\n        this._tick = scheduled;\n        // Clear the schedule if possible.\n        clearTimeout(this._timeout);\n        // Emit ticked signal, resolve pending promise, and await its settlement.\n        this._ticked.emit(this.state);\n        pending.resolve(this);\n        await pending.promise;\n        if (state.interval === Poll.NEVER) {\n            this._timeout = undefined;\n            return;\n        }\n        // Schedule next execution and cache its timeout handle.\n        const execute = () => {\n            if (this.isDisposed || this.tick !== scheduled.promise) {\n                return;\n            }\n            this._execute();\n        };\n        // Cache the handle in case it needs to be unscheduled.\n        this._timeout = setTimeout(execute, state.interval);\n    }\n    /**\n     * Starts the poll. Schedules `started` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    start() {\n        return this.schedule({\n            cancel: ({ phase }) => phase !== 'constructed' && phase !== 'standby' && phase !== 'stopped',\n            interval: Poll.IMMEDIATE,\n            phase: 'started'\n        });\n    }\n    /**\n     * Stops the poll. Schedules `stopped` tick if necessary.\n     *\n     * @returns A promise that resolves after tick is scheduled and never rejects.\n     */\n    stop() {\n        return this.schedule({\n            cancel: ({ phase }) => phase === 'stopped',\n            interval: Poll.NEVER,\n            phase: 'stopped'\n        });\n    }\n    /**\n     * Whether the poll is hidden.\n     *\n     * #### Notes\n     * This property is only relevant in a browser context.\n     */\n    get hidden() {\n        return Private.hidden;\n    }\n    /**\n     * Execute a new poll factory promise or stand by if necessary.\n     */\n    _execute() {\n        let standby = typeof this.standby === 'function' ? this.standby() : this.standby;\n        // Check if execution should proceed, linger, or stand by.\n        if (standby === 'never') {\n            standby = false;\n        }\n        else if (standby === 'when-hidden') {\n            if (this.hidden) {\n                standby = ++this._lingered > this._linger;\n            }\n            else {\n                this._lingered = 0;\n                standby = false;\n            }\n        }\n        // If in standby mode schedule next tick without calling the factory.\n        if (standby) {\n            void this.schedule();\n            return;\n        }\n        const pending = this.tick;\n        this._factory(this.state)\n            .then((resolved) => {\n            if (this.isDisposed || this.tick !== pending) {\n                return;\n            }\n            void this.schedule({\n                payload: resolved,\n                phase: this.state.phase === 'rejected' ? 'reconnected' : 'resolved'\n            });\n        })\n            .catch((rejected) => {\n            if (this.isDisposed || this.tick !== pending) {\n                return;\n            }\n            void this.schedule({\n                interval: Private.sleep(this.frequency, this.state),\n                payload: rejected,\n                phase: 'rejected'\n            });\n        });\n    }\n}\n/**\n * A namespace for `Poll` types, interfaces, and statics.\n */\n(function (Poll) {\n    /**\n     * An interval value in ms that indicates the poll should tick immediately.\n     */\n    Poll.IMMEDIATE = 0;\n    /**\n     * Delays are 32-bit integers in many browsers so intervals need to be capped.\n     *\n     * #### Notes\n     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\n     */\n    Poll.MAX_INTERVAL = 2147483647;\n    /**\n     * An interval value that indicates the poll should never tick.\n     */\n    Poll.NEVER = Infinity;\n})(Poll || (Poll = {}));\n/**\n * A namespace for private module data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The default backoff growth rate if `backoff` is `true`.\n     */\n    Private.DEFAULT_BACKOFF = 3;\n    /**\n     * The default polling frequency.\n     */\n    Private.DEFAULT_FREQUENCY = {\n        backoff: true,\n        interval: 1000,\n        max: 30 * 1000\n    };\n    /**\n     * The default number of times to `linger` when a poll is hidden.\n     */\n    Private.DEFAULT_LINGER = 1;\n    /**\n     * The default poll name.\n     */\n    Private.DEFAULT_NAME = 'unknown';\n    /**\n     * The default poll standby behavior.\n     */\n    Private.DEFAULT_STANDBY = 'when-hidden';\n    /**\n     * The first poll tick state's default values superseded in constructor.\n     */\n    Private.DEFAULT_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'constructed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * The disposed tick state values.\n     */\n    Private.DISPOSED_STATE = {\n        interval: Poll.NEVER,\n        payload: null,\n        phase: 'disposed',\n        timestamp: new Date(0).getTime()\n    };\n    /**\n     * Returns the number of milliseconds to sleep before the next tick.\n     *\n     * @param frequency - The poll's base frequency.\n     * @param last - The poll's last tick.\n     */\n    function sleep(frequency, last) {\n        const { backoff, interval, max } = frequency;\n        if (interval === Poll.NEVER) {\n            return interval;\n        }\n        const growth = backoff === true ? Private.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;\n        const random = getRandomIntInclusive(interval, last.interval * growth);\n        return Math.min(max, random);\n    }\n    Private.sleep = sleep;\n    /**\n     * Keep track of whether the document is hidden. This flag is only relevant in\n     * a browser context.\n     *\n     * Listen to `visibilitychange` event to set the `hidden` flag.\n     *\n     * Listening to `pagehide` is also necessary because Safari support for\n     * `visibilitychange` events is partial, cf.\n     * https://developer.mozilla.org/docs/Web/API/Document/visibilitychange_event\n     */\n    Private.hidden = (() => {\n        if (typeof document === 'undefined') {\n            return false;\n        }\n        document.addEventListener('visibilitychange', () => {\n            Private.hidden = document.visibilityState === 'hidden';\n        });\n        document.addEventListener('pagehide', () => {\n            Private.hidden = document.visibilityState === 'hidden';\n        });\n        return document.visibilityState === 'hidden';\n    })();\n    /**\n     * Get a random integer between min and max, inclusive of both.\n     *\n     * #### Notes\n     * From\n     * https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/random#Getting_a_random_integer_between_two_values_inclusive\n     *\n     * From the MDN page: It might be tempting to use Math.round() to accomplish\n     * that, but doing so would cause your random numbers to follow a non-uniform\n     * distribution, which may not be acceptable for your needs.\n     */\n    function getRandomIntInclusive(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n})(Private || (Private = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * A base class to implement rate limiters with different invocation strategies.\n *\n * @typeparam T - The resolved type of the underlying function.\n *\n * @typeparam U - The rejected type of the underlying function.\n *\n * @typeparam V - Arguments for the underlying function.\n */\nclass RateLimiter {\n    /**\n     * Instantiate a rate limiter.\n     *\n     * @param fn - The function to rate limit.\n     *\n     * @param limit - The rate limit; defaults to 500ms.\n     */\n    constructor(fn, limit = 500) {\n        /**\n         * Arguments for the underlying function.\n         */\n        this.args = undefined;\n        /**\n         * A promise that resolves on each successful invocation.\n         */\n        this.payload = null;\n        this.limit = limit;\n        this.poll = new Poll({\n            auto: false,\n            factory: async () => {\n                const { args } = this;\n                this.args = undefined;\n                return fn(...args);\n            },\n            frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },\n            standby: 'never'\n        });\n        this.payload = new PromiseDelegate();\n        this.poll.ticked.connect((_, state) => {\n            const { payload } = this;\n            if (state.phase === 'resolved') {\n                this.payload = new PromiseDelegate();\n                payload.resolve(state.payload);\n                return;\n            }\n            if (state.phase === 'rejected' || state.phase === 'stopped') {\n                this.payload = new PromiseDelegate();\n                payload.promise.catch(_ => undefined);\n                payload.reject(state.payload);\n                return;\n            }\n        }, this);\n    }\n    /**\n     * Whether the rate limiter is disposed.\n     */\n    get isDisposed() {\n        return this.payload === null;\n    }\n    /**\n     * Disposes the rate limiter.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.args = undefined;\n        this.payload = null;\n        this.poll.dispose();\n    }\n    /**\n     * Stop the function if it is mid-flight.\n     */\n    async stop() {\n        return this.poll.stop();\n    }\n}\n/**\n * Wraps and debounces a function that can be called multiple times and only\n * executes the underlying function one `interval` after the last invocation.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nclass Debouncer extends RateLimiter {\n    /**\n     * Invokes the function and only executes after rate limit has elapsed.\n     * Each invocation resets the timer.\n     */\n    invoke(...args) {\n        this.args = args;\n        void this.poll.schedule({ interval: this.limit, phase: 'invoked' });\n        return this.payload.promise;\n    }\n}\n/**\n * Wraps and throttles a function that can be called multiple times and only\n * executes the underlying function once per `interval`.\n *\n * @typeparam T - The resolved type of the underlying function. Defaults to any.\n *\n * @typeparam U - The rejected type of the underlying function. Defaults to any.\n *\n * @typeparam V - Arguments for the underlying function. Defaults to any[].\n */\nclass Throttler extends RateLimiter {\n    /**\n     * Instantiate a throttler.\n     *\n     * @param fn - The function being throttled.\n     *\n     * @param options - Throttling configuration or throttling limit in ms.\n     *\n     * #### Notes\n     * The `edge` defaults to `leading`; the `limit` defaults to `500`.\n     */\n    constructor(fn, options) {\n        super(fn, typeof options === 'number' ? options : options && options.limit);\n        this._trailing = false;\n        if (typeof options !== 'number' && options && options.edge === 'trailing') {\n            this._trailing = true;\n        }\n        this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;\n    }\n    /**\n     * Throttles function invocations if one is currently in flight.\n     */\n    invoke(...args) {\n        const idle = this.poll.state.phase !== 'invoked';\n        if (idle || this._trailing) {\n            this.args = args;\n        }\n        if (idle) {\n            void this.poll.schedule({ interval: this._interval, phase: 'invoked' });\n        }\n        return this.payload.promise;\n    }\n}\n\nexport { Debouncer, Poll, RateLimiter, Throttler };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Private","Poll","constructor","options","_a","this","_disposed","Signal","_lingered","_tick","PromiseDelegate","_ticked","_factory","factory","_linger","linger","DEFAULT_LINGER","_standby","standby","DEFAULT_STANDBY","_state","DEFAULT_STATE","timestamp","Date","getTime","frequency","max","Math","interval","DEFAULT_FREQUENCY","name","DEFAULT_NAME","auto","setTimeout","start","disposed","_frequency","isDisposed","JSONExt","deepEqual","backoff","round","Error","NEVER","MAX_INTERVAL","state","phase","tick","promise","ticked","Symbol","asyncIterator","catch","dispose","DISPOSED_STATE","_","reject","emit","undefined","clearData","refresh","schedule","cancel","IMMEDIATE","next","pending","scheduled","payload","clearTimeout","_timeout","resolve","_execute","stop","hidden","then","resolved","rejected","sleep","Infinity","DEFAULT_BACKOFF","last","growth","random","min","ceil","floor","getRandomIntInclusive","document","addEventListener","visibilityState","RateLimiter","fn","limit","args","poll","async","connect","Debouncer","invoke","Throttler","super","_trailing","edge","_interval","idle"],"sourceRoot":""}