{"version":3,"file":"9413.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/form.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/metadataform.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/metadataformProvider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/metadataform/lib/token.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\nimport { ReactWidget } from '@jupyterlab/apputils';\nimport { FormComponent } from '@jupyterlab/ui-components';\nimport validatorAjv8 from '@rjsf/validator-ajv8';\nimport React from 'react';\n/**\n * A ReactWidget with the form itself.\n */\nexport class FormWidget extends ReactWidget {\n    /**\n     * Constructs a new FormWidget.\n     */\n    constructor(props) {\n        super();\n        this.addClass('jp-FormWidget');\n        this._props = props;\n    }\n    /**\n     * Render the form.\n     * @returns - The rendered form\n     */\n    render() {\n        const formContext = {\n            defaultFormData: this._props.settings.default(),\n            updateMetadata: this._props.metadataFormWidget.updateMetadata\n        };\n        return (React.createElement(FormComponent, { validator: validatorAjv8, schema: this._props.properties, formData: this._props.formData, formContext: formContext, uiSchema: this._props.uiSchema, liveValidate: true, idPrefix: `jp-MetadataForm-${this._props.pluginId}`, onChange: (e) => {\n                this._props.metadataFormWidget.updateMetadata(e.formData || {});\n            }, compact: true, showModifiedFromDefault: this._props.showModified, translator: this._props.translator }));\n    }\n}\n//# sourceMappingURL=form.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\nimport { NotebookTools } from '@jupyterlab/notebook';\nimport { BaseSettings } from '@jupyterlab/settingregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { SingletonLayout, Widget } from '@lumino/widgets';\nimport { FormWidget } from './form';\n/**\n * A class that create a metadata form widget\n */\nexport class MetadataFormWidget extends NotebookTools.Tool {\n    /**\n     * Construct an empty widget.\n     */\n    constructor(options) {\n        super();\n        /**\n         * Update the metadata of the current cell or notebook.\n         *\n         * @param formData - the cell metadata set in the form.\n         * @param reload - whether to update the form after updating the metadata.\n         *\n         * ## Notes\n         * Metadata are updated from root only. If some metadata is nested,\n         * the whole root object must be updated.\n         * This function build an object with all the root object to update\n         * in metadata before performing update.\n         * It uses an arrow function to allow using 'this' properly when called from a custom field.\n         */\n        this.updateMetadata = (formData, reload) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            if (this.notebookTools == undefined)\n                return;\n            const notebook = this.notebookTools.activeNotebookPanel;\n            const cell = this.notebookTools.activeCell;\n            if (cell == null)\n                return;\n            this._updatingMetadata = true;\n            // An object representing the cell metadata to modify.\n            const cellMetadataObject = {};\n            // An object representing the notebook metadata to modify.\n            const notebookMetadataObject = {};\n            for (let [metadataKey, value] of Object.entries(formData)) {\n                // Continue if the metadataKey does not exist in schema.\n                if (!this.metadataKeys.includes(metadataKey))\n                    continue;\n                // Continue if the metadataKey is a notebook level one and there is no NotebookModel.\n                if (((_a = this._metaInformation[metadataKey]) === null || _a === void 0 ? void 0 : _a.level) === 'notebook' &&\n                    this._notebookModelNull)\n                    continue;\n                // Continue if the metadataKey is not applicable to the cell type.\n                if (((_b = this._metaInformation[metadataKey]) === null || _b === void 0 ? void 0 : _b.cellTypes) &&\n                    !((_d = (_c = this._metaInformation[metadataKey]) === null || _c === void 0 ? void 0 : _c.cellTypes) === null || _d === void 0 ? void 0 : _d.includes(cell.model.type))) {\n                    continue;\n                }\n                let currentMetadata;\n                let metadataObject;\n                // Linking the working variable to the corresponding metadata and representation.\n                if (((_e = this._metaInformation[metadataKey]) === null || _e === void 0 ? void 0 : _e.level) === 'notebook') {\n                    // Working on notebook metadata.\n                    currentMetadata = notebook.model.metadata;\n                    metadataObject = notebookMetadataObject;\n                }\n                else {\n                    // Working on cell metadata.\n                    currentMetadata = cell.model.metadata;\n                    metadataObject = cellMetadataObject;\n                }\n                // Remove first and last '/' if necessary and split the path.\n                let nestedKey = metadataKey\n                    .replace(/^\\/+/, '')\n                    .replace(/\\/+$/, '')\n                    .split('/');\n                let baseMetadataKey = nestedKey[0];\n                if (baseMetadataKey == undefined)\n                    continue;\n                let writeFinalData = value !== undefined &&\n                    (((_g = (_f = this._metaInformation[metadataKey]) === null || _f === void 0 ? void 0 : _f.writeDefault) !== null && _g !== void 0 ? _g : true) ||\n                        value !== ((_h = this._metaInformation[metadataKey]) === null || _h === void 0 ? void 0 : _h.default));\n                // If metadata key is at root of metadata no need to go further.\n                if (nestedKey.length == 1) {\n                    if (writeFinalData)\n                        metadataObject[baseMetadataKey] = value;\n                    else\n                        metadataObject[baseMetadataKey] = undefined;\n                    continue;\n                }\n                let intermediateMetadataKeys = nestedKey.slice(1, -1);\n                let finalMetadataKey = nestedKey[nestedKey.length - 1];\n                // Deep copy of the metadata if not already done.\n                if (!(baseMetadataKey in metadataObject)) {\n                    metadataObject[baseMetadataKey] = currentMetadata[baseMetadataKey];\n                }\n                if (metadataObject[baseMetadataKey] === undefined)\n                    metadataObject[baseMetadataKey] = {};\n                // Let's have an object which points to the nested key.\n                let workingObject = metadataObject[baseMetadataKey];\n                let finalObjectReached = true;\n                for (let nested of intermediateMetadataKeys) {\n                    // If one of the nested object does not exist, this object is created\n                    // only if there is a final data to write.\n                    if (!(nested in workingObject)) {\n                        if (!writeFinalData) {\n                            finalObjectReached = false;\n                            break;\n                        }\n                        else\n                            workingObject[nested] = {};\n                    }\n                    workingObject = workingObject[nested];\n                }\n                // Write the value to the nested key or remove all empty object before the nested key,\n                // only if the final object has been reached.\n                if (finalObjectReached) {\n                    if (!writeFinalData)\n                        delete workingObject[finalMetadataKey];\n                    else\n                        workingObject[finalMetadataKey] = value;\n                }\n                // If the final nested data has been deleted, let see if there is not remaining\n                // empty objects to remove.\n                if (!writeFinalData) {\n                    metadataObject[baseMetadataKey] = Private.deleteEmptyNested(metadataObject[baseMetadataKey], nestedKey.slice(1));\n                    if (!Object.keys(metadataObject[baseMetadataKey])\n                        .length)\n                        metadataObject[baseMetadataKey] = undefined;\n                }\n            }\n            // Set the cell metadata or delete it if value is undefined or empty object.\n            for (let [key, value] of Object.entries(cellMetadataObject)) {\n                if (value === undefined)\n                    cell.model.deleteMetadata(key);\n                else\n                    cell.model.setMetadata(key, value);\n            }\n            // Set the notebook metadata or delete it if value is undefined or empty object.\n            if (!this._notebookModelNull) {\n                for (let [key, value] of Object.entries(notebookMetadataObject)) {\n                    if (value === undefined)\n                        notebook.model.deleteMetadata(key);\n                    else\n                        notebook.model.setMetadata(key, value);\n                }\n            }\n            this._updatingMetadata = false;\n            if (reload) {\n                this._update();\n            }\n        };\n        this._notebookModelNull = false;\n        this._metadataSchema = options.metadataSchema;\n        this._metaInformation = options.metaInformation;\n        this._uiSchema = options.uiSchema || {};\n        this._pluginId = options.pluginId;\n        this._showModified = options.showModified || false;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._updatingMetadata = false;\n        const layout = (this.layout = new SingletonLayout());\n        const node = document.createElement('div');\n        const content = document.createElement('div');\n        content.textContent = this._trans.__('No metadata.');\n        content.className = 'jp-MetadataForm-placeholderContent';\n        node.appendChild(content);\n        this._placeholder = new Widget({ node });\n        this._placeholder.addClass('jp-MetadataForm-placeholder');\n        layout.widget = this._placeholder;\n    }\n    /**\n     * Get the form object itself.\n     */\n    get form() {\n        return this._form;\n    }\n    /**\n     * Get the list of existing metadataKey (array of string).\n     *\n     * ## NOTE:\n     * The list contains also the conditional fields, which are not necessary\n     * displayed and filled.\n     */\n    get metadataKeys() {\n        var _a;\n        const metadataKeys = [];\n        // MetadataKey from schema.\n        for (let metadataKey of Object.keys(this._metadataSchema.properties)) {\n            metadataKeys.push(metadataKey);\n        }\n        // Possible additional metadataKeys from conditional schema.\n        (_a = this._metadataSchema.allOf) === null || _a === void 0 ? void 0 : _a.forEach(conditional => {\n            if (conditional.then !== undefined) {\n                if (conditional.then.properties !== undefined) {\n                    let properties = conditional.then\n                        .properties;\n                    for (let metadataKey of Object.keys(properties)) {\n                        if (!metadataKeys.includes(metadataKey))\n                            metadataKeys.push(metadataKey);\n                    }\n                }\n            }\n            if (conditional.else !== undefined) {\n                if (conditional.else.properties !== undefined) {\n                    let properties = conditional.else\n                        .properties;\n                    for (let metadataKey of Object.keys(properties)) {\n                        if (!metadataKeys.includes(metadataKey))\n                            metadataKeys.push(metadataKey);\n                    }\n                }\n            }\n        });\n        return metadataKeys;\n    }\n    /**\n     * Get the properties of a MetadataKey.\n     *\n     * @param metadataKey - metadataKey (string).\n     */\n    getProperties(metadataKey) {\n        return (JSONExt.deepCopy(this._metadataSchema.properties[metadataKey]) || null);\n    }\n    /**\n     * Set properties to a metadataKey.\n     *\n     * @param metadataKey - metadataKey (string).\n     * @param properties - the properties to add or modify.\n     */\n    setProperties(metadataKey, properties) {\n        Object.entries(properties).forEach(([key, value]) => {\n            this._metadataSchema.properties[metadataKey][key] = value;\n        });\n    }\n    /**\n     * Set the content of the widget.\n     */\n    setContent(content) {\n        const layout = this.layout;\n        if (layout.widget) {\n            layout.widget.removeClass('jp-MetadataForm-content');\n            layout.removeWidget(layout.widget);\n        }\n        if (!content) {\n            content = this._placeholder;\n        }\n        content.addClass('jp-MetadataForm-content');\n        layout.widget = content;\n    }\n    /**\n     * Build widget.\n     */\n    buildWidget(props) {\n        this._form = new FormWidget(props);\n        this._form.addClass('jp-MetadataForm');\n        this.setContent(this._form);\n    }\n    /**\n     * Update the form when the widget is displayed.\n     */\n    onAfterShow(msg) {\n        this._update();\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    onActiveCellChanged(msg) {\n        if (this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle a change to the active cell metadata.\n     */\n    onActiveCellMetadataChanged(_) {\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle when the active notebook panel changes.\n     */\n    onActiveNotebookPanelChanged(_) {\n        const notebook = this.notebookTools.activeNotebookPanel;\n        this._notebookModelNull = notebook === null || notebook.model === null;\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Handle a change to the active notebook metadata.\n     */\n    onActiveNotebookPanelMetadataChanged(msg) {\n        if (!this._updatingMetadata && this.isVisible)\n            this._update();\n    }\n    /**\n     * Update the form with current cell metadata, and remove inconsistent fields.\n     */\n    _update() {\n        var _a, _b, _c, _d, _e;\n        const notebook = this.notebookTools.activeNotebookPanel;\n        const cell = this.notebookTools.activeCell;\n        if (cell == undefined)\n            return;\n        const formProperties = JSONExt.deepCopy(this._metadataSchema);\n        const formData = {};\n        for (let metadataKey of Object.keys(this._metadataSchema.properties || JSONExt.emptyObject)) {\n            // Do not display the field if it's Notebook metadata and the notebook model is null.\n            if (((_a = this._metaInformation[metadataKey]) === null || _a === void 0 ? void 0 : _a.level) === 'notebook' &&\n                this._notebookModelNull) {\n                delete formProperties.properties[metadataKey];\n                continue;\n            }\n            // Do not display the field if the active cell's type is not involved.\n            if (((_b = this._metaInformation[metadataKey]) === null || _b === void 0 ? void 0 : _b.cellTypes) &&\n                !((_d = (_c = this._metaInformation[metadataKey]) === null || _c === void 0 ? void 0 : _c.cellTypes) === null || _d === void 0 ? void 0 : _d.includes(cell.model.type))) {\n                delete formProperties.properties[metadataKey];\n                continue;\n            }\n            let workingObject;\n            // Remove the first and last '/' if exist, nad split the path.\n            let nestedKeys = metadataKey\n                .replace(/^\\/+/, '')\n                .replace(/\\/+$/, '')\n                .split('/');\n            // Associates the correct metadata object to the working object.\n            if (((_e = this._metaInformation[metadataKey]) === null || _e === void 0 ? void 0 : _e.level) === 'notebook') {\n                workingObject = notebook.model.metadata;\n            }\n            else {\n                workingObject = cell.model.metadata;\n            }\n            let hasValue = true;\n            // Navigate to the value.\n            for (let nested of nestedKeys) {\n                if (nested in workingObject)\n                    workingObject = workingObject[nested];\n                else {\n                    hasValue = false;\n                    break;\n                }\n            }\n            // Fill the formData with the current metadata value.\n            if (hasValue)\n                formData[metadataKey] = workingObject;\n        }\n        this.buildWidget({\n            properties: formProperties,\n            settings: new BaseSettings({\n                schema: this._metadataSchema\n            }),\n            uiSchema: this._uiSchema,\n            translator: this.translator || null,\n            formData: formData,\n            metadataFormWidget: this,\n            showModified: this._showModified,\n            pluginId: this._pluginId\n        });\n    }\n}\nvar Private;\n(function (Private) {\n    /**\n     * Recursive function to clean the empty nested metadata before updating real metadata.\n     * this function is called when a nested metadata is undefined (or default), so maybe some\n     * object are now empty.\n     * @param metadataObject PartialJSONObject representing the metadata to update.\n     * @param metadataKeysList Array<string> of the undefined nested metadata.\n     * @returns PartialJSONObject without empty object.\n     */\n    function deleteEmptyNested(metadataObject, metadataKeysList) {\n        let metadataKey = metadataKeysList.shift();\n        if (metadataKey !== undefined && metadataKey in metadataObject) {\n            if (Object.keys(metadataObject[metadataKey]).length)\n                metadataObject[metadataKey] = deleteEmptyNested(metadataObject[metadataKey], metadataKeysList);\n            if (!Object.keys(metadataObject[metadataKey]).length)\n                delete metadataObject[metadataKey];\n        }\n        return metadataObject;\n    }\n    Private.deleteEmptyNested = deleteEmptyNested;\n})(Private || (Private = {}));\n//# sourceMappingURL=metadataform.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nexport class MetadataFormProvider {\n    constructor() {\n        this._items = {};\n    }\n    add(id, widget) {\n        if (!this._items[id]) {\n            this._items[id] = widget;\n        }\n        else {\n            console.warn(`A MetadataformWidget is already registered with id ${id}`);\n        }\n    }\n    get(id) {\n        if (this._items[id]) {\n            return this._items[id];\n        }\n        else {\n            console.warn(`There is no MetadataformWidget registered with id ${id}`);\n        }\n    }\n}\n//# sourceMappingURL=metadataformProvider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module metadataform\n */\nimport { Token } from '@lumino/coreutils';\n/**\n * The metadata form provider token.\n */\nexport const IMetadataFormProvider = new Token('@jupyterlab/metadataform:IMetadataFormProvider', `A service to register new metadata editor widgets.`);\n//# sourceMappingURL=token.js.map"],"names":["FormWidget","ReactWidget","constructor","props","super","this","addClass","_props","render","formContext","defaultFormData","settings","default","updateMetadata","metadataFormWidget","FormComponent","validator","schema","properties","formData","uiSchema","liveValidate","idPrefix","pluginId","onChange","e","compact","showModifiedFromDefault","showModified","translator","Private","MetadataFormWidget","NotebookTools","Tool","options","reload","_a","_b","_c","_d","_e","_f","_g","_h","undefined","notebookTools","notebook","activeNotebookPanel","cell","activeCell","_updatingMetadata","cellMetadataObject","notebookMetadataObject","metadataKey","value","Object","entries","metadataKeys","includes","_metaInformation","level","_notebookModelNull","cellTypes","model","type","currentMetadata","metadataObject","metadata","nestedKey","replace","split","baseMetadataKey","writeFinalData","writeDefault","length","intermediateMetadataKeys","slice","finalMetadataKey","workingObject","finalObjectReached","nested","deleteEmptyNested","keys","key","deleteMetadata","setMetadata","_update","_metadataSchema","metadataSchema","metaInformation","_uiSchema","_pluginId","_showModified","nullTranslator","_trans","load","layout","SingletonLayout","node","document","createElement","content","textContent","__","className","appendChild","_placeholder","Widget","widget","form","_form","push","allOf","forEach","conditional","then","else","getProperties","JSONExt","deepCopy","setProperties","setContent","removeClass","removeWidget","buildWidget","onAfterShow","msg","onActiveCellChanged","isVisible","onActiveCellMetadataChanged","_","onActiveNotebookPanelChanged","onActiveNotebookPanelMetadataChanged","formProperties","emptyObject","nestedKeys","hasValue","BaseSettings","metadataKeysList","shift","MetadataFormProvider","_items","add","id","console","warn","get","IMetadataFormProvider","Token"],"sourceRoot":""}