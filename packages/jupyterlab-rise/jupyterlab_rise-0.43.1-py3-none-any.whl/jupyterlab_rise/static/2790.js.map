{"version":3,"file":"2790.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/dragdrop/dist/index.es6.js"],"sourcesContent":["import { DisposableDelegate } from '@lumino/disposable';\n\n/**\n * An object which manages a drag-drop operation.\n *\n * A drag object dispatches four different events to drop targets:\n *\n * - `'lm-dragenter'` - Dispatched when the mouse enters the target\n *   element. This event must be canceled in order to receive any\n *   of the other events.\n *\n * - `'lm-dragover'` - Dispatched when the mouse moves over the drop\n *   target. It must cancel the event and set the `dropAction` to one\n *   of the supported actions in order to receive drop events.\n *\n * - `'lm-dragleave'` - Dispatched when the mouse leaves the target\n *   element. This includes moving the mouse into child elements.\n *\n * - `'lm-drop'`- Dispatched when the mouse is released over the target\n *   element when the target indicates an appropriate drop action. If\n *   the event is canceled, the indicated drop action is returned to\n *   the initiator through the resolved promise.\n *\n * A drag operation can be terminated at any time by pressing `Escape`\n * or by disposing the drag object.\n *\n * A drag object has the ability to automatically scroll a scrollable\n * element when the mouse is hovered near one of its edges. To enable\n * this, add the `data-lm-dragscroll` attribute to any element which\n * the drag object should consider for scrolling.\n *\n * #### Notes\n * This class is designed to be used when dragging and dropping custom\n * data *within* a single application. It is *not* a replacement for\n * the native drag-drop API. Instead, it provides an API which allows\n * drag operations to be initiated programmatically and enables the\n * transfer of arbitrary non-string objects; features which are not\n * possible with the native drag-drop API.\n */\nclass Drag {\n    /**\n     * Construct a new drag object.\n     *\n     * @param options - The options for initializing the drag.\n     */\n    constructor(options) {\n        /**\n         * The scroll loop handler function.\n         */\n        this._onScrollFrame = () => {\n            // Bail early if there is no scroll target.\n            if (!this._scrollTarget) {\n                return;\n            }\n            // Unpack the scroll target.\n            let { element, edge, distance } = this._scrollTarget;\n            // Calculate the scroll delta using nonlinear acceleration.\n            let d = Private.SCROLL_EDGE_SIZE - distance;\n            let f = Math.pow(d / Private.SCROLL_EDGE_SIZE, 2);\n            let s = Math.max(1, Math.round(f * Private.SCROLL_EDGE_SIZE));\n            // Scroll the element in the specified direction.\n            switch (edge) {\n                case 'top':\n                    element.scrollTop -= s;\n                    break;\n                case 'left':\n                    element.scrollLeft -= s;\n                    break;\n                case 'right':\n                    element.scrollLeft += s;\n                    break;\n                case 'bottom':\n                    element.scrollTop += s;\n                    break;\n            }\n            // Request the next cycle of the scroll loop.\n            requestAnimationFrame(this._onScrollFrame);\n        };\n        this._disposed = false;\n        this._dropAction = 'none';\n        this._override = null;\n        this._currentTarget = null;\n        this._currentElement = null;\n        this._promise = null;\n        this._scrollTarget = null;\n        this._resolve = null;\n        this.document = options.document || document;\n        this.mimeData = options.mimeData;\n        this.dragImage = options.dragImage || null;\n        this.proposedAction = options.proposedAction || 'copy';\n        this.supportedActions = options.supportedActions || 'all';\n        this.source = options.source || null;\n    }\n    /**\n     * Dispose of the resources held by the drag object.\n     *\n     * #### Notes\n     * This will cancel the drag operation if it is active.\n     */\n    dispose() {\n        // Do nothing if the drag object is already disposed.\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        // If there is a current target, dispatch a drag leave event.\n        if (this._currentTarget) {\n            let event = new PointerEvent('pointerup', {\n                bubbles: true,\n                cancelable: true,\n                clientX: -1,\n                clientY: -1\n            });\n            Private.dispatchDragLeave(this, this._currentTarget, null, event);\n        }\n        // Finalize the drag object with `'none'`.\n        this._finalize('none');\n    }\n    /**\n     * Test whether the drag object is disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Start the drag operation at the specified client position.\n     *\n     * @param clientX - The client X position for the drag start.\n     *\n     * @param clientY - The client Y position for the drag start.\n     *\n     * @returns A promise which resolves to the result of the drag.\n     *\n     * #### Notes\n     * If the drag has already been started, the promise created by the\n     * first call to `start` is returned.\n     *\n     * If the drag operation has ended, or if the drag object has been\n     * disposed, the returned promise will resolve to `'none'`.\n     *\n     * The drag object will be automatically disposed when drag operation\n     * completes. This means `Drag` objects are for single-use only.\n     *\n     * This method assumes the left mouse button is already held down.\n     */\n    start(clientX, clientY) {\n        // If the drag object is already disposed, resolve to `none`.\n        if (this._disposed) {\n            return Promise.resolve('none');\n        }\n        // If the drag has already been started, return the promise.\n        if (this._promise) {\n            return this._promise;\n        }\n        // Install the document listeners for the drag object.\n        this._addListeners();\n        // Attach the drag image at the specified client position.\n        this._attachDragImage(clientX, clientY);\n        // Create the promise which will be resolved on completion.\n        this._promise = new Promise(resolve => {\n            this._resolve = resolve;\n        });\n        // Trigger a fake move event to kick off the drag operation.\n        let event = new PointerEvent('pointermove', {\n            bubbles: true,\n            cancelable: true,\n            clientX,\n            clientY\n        });\n        document.dispatchEvent(event);\n        // Return the pending promise for the drag operation.\n        return this._promise;\n    }\n    /**\n     * Handle the DOM events for the drag operation.\n     *\n     * @param event - The DOM event sent to the drag object.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the document. It should not be\n     * called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'pointermove':\n                this._evtPointerMove(event);\n                break;\n            case 'pointerup':\n                this._evtPointerUp(event);\n                break;\n            case 'keydown':\n                this._evtKeyDown(event);\n                break;\n            default:\n                // Stop all other events during drag-drop.\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n        }\n    }\n    /**\n     * Move the drag image element to the specified location.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    moveDragImage(clientX, clientY) {\n        if (!this.dragImage) {\n            return;\n        }\n        let style = this.dragImage.style;\n        style.transform = `translate(${clientX}px, ${clientY}px)`;\n    }\n    /**\n     * Handle the `'pointermove'` event for the drag object.\n     */\n    _evtPointerMove(event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Update the current target node and dispatch enter/leave events.\n        this._updateCurrentTarget(event);\n        // Update the drag scroll element.\n        this._updateDragScroll(event);\n        // Move the drag image to the specified client position. This is\n        // performed *after* dispatching to prevent unnecessary reflows.\n        this.moveDragImage(event.clientX, event.clientY);\n    }\n    /**\n     * Handle the `'pointerup'` event for the drag object.\n     */\n    _evtPointerUp(event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Do nothing if the left button is not released.\n        if (event.button !== 0) {\n            return;\n        }\n        // Update the current target node and dispatch enter/leave events.\n        // This prevents a subtle issue where the DOM mutates under the\n        // cursor after the last move event but before the drop event.\n        this._updateCurrentTarget(event);\n        // If there is no current target, finalize with `'none'`.\n        if (!this._currentTarget) {\n            this._finalize('none');\n            return;\n        }\n        // If the last drop action was `'none'`, dispatch a leave event\n        // to the current target and finalize the drag with `'none'`.\n        if (this._dropAction === 'none') {\n            Private.dispatchDragLeave(this, this._currentTarget, null, event);\n            this._finalize('none');\n            return;\n        }\n        // Dispatch the drop event at the current target and finalize\n        // with the resulting drop action.\n        let action = Private.dispatchDrop(this, this._currentTarget, event);\n        this._finalize(action);\n    }\n    /**\n     * Handle the `'keydown'` event for the drag object.\n     */\n    _evtKeyDown(event) {\n        // Stop all input events during drag-drop.\n        event.preventDefault();\n        event.stopPropagation();\n        // Cancel the drag if `Escape` is pressed.\n        if (event.keyCode === 27) {\n            this.dispose();\n        }\n    }\n    /**\n     * Add the document event listeners for the drag object.\n     */\n    _addListeners() {\n        document.addEventListener('pointerdown', this, true);\n        document.addEventListener('pointermove', this, true);\n        document.addEventListener('pointerup', this, true);\n        document.addEventListener('pointerenter', this, true);\n        document.addEventListener('pointerleave', this, true);\n        document.addEventListener('pointerover', this, true);\n        document.addEventListener('pointerout', this, true);\n        document.addEventListener('keydown', this, true);\n        document.addEventListener('keyup', this, true);\n        document.addEventListener('keypress', this, true);\n        document.addEventListener('contextmenu', this, true);\n    }\n    /**\n     * Remove the document event listeners for the drag object.\n     */\n    _removeListeners() {\n        document.removeEventListener('pointerdown', this, true);\n        document.removeEventListener('pointermove', this, true);\n        document.removeEventListener('pointerup', this, true);\n        document.removeEventListener('pointerenter', this, true);\n        document.removeEventListener('pointerleave', this, true);\n        document.removeEventListener('pointerover', this, true);\n        document.removeEventListener('pointerout', this, true);\n        document.removeEventListener('keydown', this, true);\n        document.removeEventListener('keyup', this, true);\n        document.removeEventListener('keypress', this, true);\n        document.removeEventListener('contextmenu', this, true);\n    }\n    /**\n     * Update the drag scroll element under the mouse.\n     */\n    _updateDragScroll(event) {\n        // Find the scroll target under the mouse.\n        let target = Private.findScrollTarget(event);\n        // Bail if there is nothing to scroll.\n        if (!this._scrollTarget && !target) {\n            return;\n        }\n        // Start the scroll loop if needed.\n        if (!this._scrollTarget) {\n            setTimeout(this._onScrollFrame, 500);\n        }\n        // Update the scroll target.\n        this._scrollTarget = target;\n    }\n    /**\n     * Update the current target node using the given mouse event.\n     */\n    _updateCurrentTarget(event) {\n        // Fetch common local state.\n        let prevTarget = this._currentTarget;\n        let currTarget = this._currentTarget;\n        let prevElem = this._currentElement;\n        // Find the current indicated element at the given position.\n        let currElem = Private.findElementBehindBackdrop(event, this.document);\n        // Update the current element reference.\n        this._currentElement = currElem;\n        // If the indicated element changes from the previous iteration,\n        // and is different from the current target, dispatch the exit\n        // event to the target.\n        if (currElem !== prevElem && currElem !== currTarget) {\n            Private.dispatchDragExit(this, currTarget, currElem, event);\n        }\n        // If the indicated element changes from the previous iteration,\n        // and is different from the current target, dispatch the enter\n        // event and compute the new target element.\n        if (currElem !== prevElem && currElem !== currTarget) {\n            currTarget = Private.dispatchDragEnter(this, currElem, currTarget, event);\n        }\n        // If the current target element has changed, update the current\n        // target reference and dispatch the leave event to the old target.\n        if (currTarget !== prevTarget) {\n            this._currentTarget = currTarget;\n            Private.dispatchDragLeave(this, prevTarget, currTarget, event);\n        }\n        // Dispatch the drag over event and update the drop action.\n        let action = Private.dispatchDragOver(this, currTarget, event);\n        this._setDropAction(action);\n    }\n    /**\n     * Attach the drag image element at the specified location.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    _attachDragImage(clientX, clientY) {\n        if (!this.dragImage) {\n            return;\n        }\n        this.dragImage.classList.add('lm-mod-drag-image');\n        let style = this.dragImage.style;\n        style.pointerEvents = 'none';\n        style.position = 'fixed';\n        style.transform = `translate(${clientX}px, ${clientY}px)`;\n        const body = this.document instanceof Document\n            ? this.document.body\n            : this.document.firstElementChild;\n        body.appendChild(this.dragImage);\n    }\n    /**\n     * Detach the drag image element from the DOM.\n     *\n     * This is a no-op if there is no drag image element.\n     */\n    _detachDragImage() {\n        if (!this.dragImage) {\n            return;\n        }\n        let parent = this.dragImage.parentNode;\n        if (!parent) {\n            return;\n        }\n        parent.removeChild(this.dragImage);\n    }\n    /**\n     * Set the internal drop action state and update the drag cursor.\n     */\n    _setDropAction(action) {\n        action = Private.validateAction(action, this.supportedActions);\n        if (this._override && this._dropAction === action) {\n            return;\n        }\n        switch (action) {\n            case 'none':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('no-drop', this.document);\n                break;\n            case 'copy':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('copy', this.document);\n                break;\n            case 'link':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('alias', this.document);\n                break;\n            case 'move':\n                this._dropAction = action;\n                this._override = Drag.overrideCursor('move', this.document);\n                break;\n        }\n    }\n    /**\n     * Finalize the drag operation and resolve the drag promise.\n     */\n    _finalize(action) {\n        // Store the resolve function as a temp variable.\n        let resolve = this._resolve;\n        // Remove the document event listeners.\n        this._removeListeners();\n        // Detach the drag image.\n        this._detachDragImage();\n        // Dispose of the cursor override.\n        if (this._override) {\n            this._override.dispose();\n            this._override = null;\n        }\n        // Clear the mime data.\n        this.mimeData.clear();\n        // Clear the rest of the internal drag state.\n        this._disposed = true;\n        this._dropAction = 'none';\n        this._currentTarget = null;\n        this._currentElement = null;\n        this._scrollTarget = null;\n        this._promise = null;\n        this._resolve = null;\n        // Finally, resolve the promise to the given drop action.\n        if (resolve) {\n            resolve(action);\n        }\n    }\n}\n/**\n * The namespace for the `Drag` class statics.\n */\n(function (Drag) {\n    /**\n     * A custom event used for drag-drop operations.\n     *\n     * #### Notes\n     * In order to receive `'lm-dragover'`, `'lm-dragleave'`, or `'lm-drop'`\n     * events, a drop target must cancel the `'lm-dragenter'` event by\n     * calling the event's `preventDefault()` method.\n     */\n    class Event extends DragEvent {\n        constructor(event, options) {\n            super(options.type, {\n                bubbles: true,\n                cancelable: true,\n                altKey: event.altKey,\n                button: event.button,\n                clientX: event.clientX,\n                clientY: event.clientY,\n                ctrlKey: event.ctrlKey,\n                detail: 0,\n                metaKey: event.metaKey,\n                relatedTarget: options.related,\n                screenX: event.screenX,\n                screenY: event.screenY,\n                shiftKey: event.shiftKey,\n                view: window\n            });\n            const { drag } = options;\n            this.dropAction = 'none';\n            this.mimeData = drag.mimeData;\n            this.proposedAction = drag.proposedAction;\n            this.supportedActions = drag.supportedActions;\n            this.source = drag.source;\n        }\n    }\n    Drag.Event = Event;\n    /**\n     * Override the cursor icon for the entire document.\n     *\n     * @param cursor - The string representing the cursor style.\n     *\n     * @returns A disposable which will clear the override when disposed.\n     *\n     * #### Notes\n     * The most recent call to `overrideCursor` takes precedence.\n     * Disposing an old override has no effect on the current override.\n     *\n     * This utility function is used by the `Drag` class to override the\n     * mouse cursor during a drag-drop operation, but it can also be used\n     * by other classes to fix the cursor icon during normal mouse drags.\n     *\n     * #### Example\n     * ```typescript\n     * import { Drag } from '@lumino/dragdrop';\n     *\n     * // Force the cursor to be 'wait' for the entire document.\n     * let override = Drag.overrideCursor('wait');\n     *\n     * // Clear the override by disposing the return value.\n     * override.dispose();\n     * ```\n     */\n    function overrideCursor(cursor, doc = document) {\n        return Private.overrideCursor(cursor, doc);\n    }\n    Drag.overrideCursor = overrideCursor;\n})(Drag || (Drag = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The size of a drag scroll edge, in pixels.\n     */\n    Private.SCROLL_EDGE_SIZE = 20;\n    /**\n     * Validate the given action is one of the supported actions.\n     *\n     * Returns the given action or `'none'` if the action is unsupported.\n     */\n    function validateAction(action, supported) {\n        return actionTable[action] & supportedTable[supported] ? action : 'none';\n    }\n    Private.validateAction = validateAction;\n    /**\n     * Find the event target using pointer position if given, or otherwise\n     * the central position of the backdrop.\n     */\n    function findElementBehindBackdrop(event, root = document) {\n        if (event) {\n            // Check if we already cached element for this event.\n            if (lastElementEventSearch && event == lastElementEventSearch.event) {\n                return lastElementEventSearch.element;\n            }\n            Private.cursorBackdrop.style.zIndex = '-1000';\n            const element = root.elementFromPoint(event.clientX, event.clientY);\n            Private.cursorBackdrop.style.zIndex = '';\n            lastElementEventSearch = { event, element };\n            return element;\n        }\n        else {\n            const transform = Private.cursorBackdrop.style.transform;\n            if (lastElementSearch && transform === lastElementSearch.transform) {\n                return lastElementSearch.element;\n            }\n            const bbox = Private.cursorBackdrop.getBoundingClientRect();\n            Private.cursorBackdrop.style.zIndex = '-1000';\n            const element = root.elementFromPoint(bbox.left + bbox.width / 2, bbox.top + bbox.height / 2);\n            Private.cursorBackdrop.style.zIndex = '';\n            lastElementSearch = { transform, element };\n            return element;\n        }\n    }\n    Private.findElementBehindBackdrop = findElementBehindBackdrop;\n    let lastElementEventSearch = null;\n    let lastElementSearch = null;\n    /**\n     * Find the drag scroll target under the mouse, if any.\n     */\n    function findScrollTarget(event) {\n        // Look up the client mouse position.\n        let x = event.clientX;\n        let y = event.clientY;\n        // Get the element under the mouse.\n        let element = findElementBehindBackdrop(event);\n        // Search for a scrollable target based on the mouse position.\n        // The null assert in third clause of for-loop is required due to:\n        // https://github.com/Microsoft/TypeScript/issues/14143\n        for (; element; element = element.parentElement) {\n            // Ignore elements which are not marked as scrollable.\n            if (!element.hasAttribute('data-lm-dragscroll')) {\n                continue;\n            }\n            // Set up the coordinate offsets for the element.\n            let offsetX = 0;\n            let offsetY = 0;\n            if (element === document.body) {\n                offsetX = window.pageXOffset;\n                offsetY = window.pageYOffset;\n            }\n            // Get the element bounds in viewport coordinates.\n            let r = element.getBoundingClientRect();\n            let top = r.top + offsetY;\n            let left = r.left + offsetX;\n            let right = left + r.width;\n            let bottom = top + r.height;\n            // Skip the element if it's not under the mouse.\n            if (x < left || x >= right || y < top || y >= bottom) {\n                continue;\n            }\n            // Compute the distance to each edge.\n            let dl = x - left + 1;\n            let dt = y - top + 1;\n            let dr = right - x;\n            let db = bottom - y;\n            // Find the smallest of the edge distances.\n            let distance = Math.min(dl, dt, dr, db);\n            // Skip the element if the mouse is not within a scroll edge.\n            if (distance > Private.SCROLL_EDGE_SIZE) {\n                continue;\n            }\n            // Set up the edge result variable.\n            let edge;\n            // Find the edge for the computed distance.\n            switch (distance) {\n                case db:\n                    edge = 'bottom';\n                    break;\n                case dt:\n                    edge = 'top';\n                    break;\n                case dr:\n                    edge = 'right';\n                    break;\n                case dl:\n                    edge = 'left';\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n            // Compute how much the element can scroll in width and height.\n            let dsw = element.scrollWidth - element.clientWidth;\n            let dsh = element.scrollHeight - element.clientHeight;\n            // Determine if the element should be scrolled for the edge.\n            let shouldScroll;\n            switch (edge) {\n                case 'top':\n                    shouldScroll = dsh > 0 && element.scrollTop > 0;\n                    break;\n                case 'left':\n                    shouldScroll = dsw > 0 && element.scrollLeft > 0;\n                    break;\n                case 'right':\n                    shouldScroll = dsw > 0 && element.scrollLeft < dsw;\n                    break;\n                case 'bottom':\n                    shouldScroll = dsh > 0 && element.scrollTop < dsh;\n                    break;\n                default:\n                    throw 'unreachable';\n            }\n            // Skip the element if it should not be scrolled.\n            if (!shouldScroll) {\n                continue;\n            }\n            // Return the drag scroll target.\n            return { element, edge, distance };\n        }\n        // No drag scroll target was found.\n        return null;\n    }\n    Private.findScrollTarget = findScrollTarget;\n    /**\n     * Dispatch a drag enter event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currElem - The currently indicated element, or `null`. This\n     *   is the \"immediate user selection\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The element to use as the current drag target. This is the\n     *   \"current target element\" from the whatwg spec, and may be `null`.\n     *\n     * #### Notes\n     * This largely implements the drag enter portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragEnter(drag, currElem, currTarget, event) {\n        // If the current element is null, return null as the new target.\n        if (!currElem) {\n            return null;\n        }\n        // Dispatch a drag enter event to the current element.\n        let dragEvent = new Drag.Event(event, {\n            drag,\n            related: currTarget,\n            type: 'lm-dragenter'\n        });\n        let canceled = !currElem.dispatchEvent(dragEvent);\n        // If the event was canceled, use the current element as the new target.\n        if (canceled) {\n            return currElem;\n        }\n        // If the current element is the document body, keep the original target.\n        const body = drag.document instanceof Document\n            ? drag.document.body\n            : drag.document.firstElementChild;\n        if (currElem === body) {\n            return currTarget;\n        }\n        // Dispatch a drag enter event on the document body.\n        dragEvent = new Drag.Event(event, {\n            drag,\n            related: currTarget,\n            type: 'lm-dragenter'\n        });\n        body.dispatchEvent(dragEvent);\n        // Ignore the event cancellation, and use the body as the new target.\n        return body;\n    }\n    Private.dispatchDragEnter = dispatchDragEnter;\n    /**\n     * Dispatch a drag exit event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param prevTarget - The previous target element, or `null`. This\n     *   is the previous \"current target element\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * #### Notes\n     * This largely implements the drag exit portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragExit(drag, prevTarget, currTarget, event) {\n        // If the previous target is null, do nothing.\n        if (!prevTarget) {\n            return;\n        }\n        // Dispatch the drag exit event to the previous target.\n        let dragEvent = new Drag.Event(event, {\n            drag,\n            related: currTarget,\n            type: 'lm-dragexit'\n        });\n        prevTarget.dispatchEvent(dragEvent);\n    }\n    Private.dispatchDragExit = dispatchDragExit;\n    /**\n     * Dispatch a drag leave event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param prevTarget - The previous target element, or `null`. This\n     *   is the previous \"current target element\" from the whatwg spec.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * #### Notes\n     * This largely implements the drag leave portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragLeave(drag, prevTarget, currTarget, event) {\n        // If the previous target is null, do nothing.\n        if (!prevTarget) {\n            return;\n        }\n        // Dispatch the drag leave event to the previous target.\n        let dragEvent = new Drag.Event(event, {\n            drag,\n            related: currTarget,\n            type: 'lm-dragleave'\n        });\n        prevTarget.dispatchEvent(dragEvent);\n    }\n    Private.dispatchDragLeave = dispatchDragLeave;\n    /**\n     * Dispatch a drag over event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The `DropAction` result of the drag over event.\n     *\n     * #### Notes\n     * This largely implements the drag over portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDragOver(drag, currTarget, event) {\n        // If there is no current target, the drop action is none.\n        if (!currTarget) {\n            return 'none';\n        }\n        // Dispatch the drag over event to the current target.\n        let dragEvent = new Drag.Event(event, {\n            drag,\n            related: null,\n            type: 'lm-dragover'\n        });\n        let canceled = !currTarget.dispatchEvent(dragEvent);\n        // If the event was canceled, return the drop action result.\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        // Otherwise, the effective drop action is none.\n        return 'none';\n    }\n    Private.dispatchDragOver = dispatchDragOver;\n    /**\n     * Dispatch a drop event to the indicated element.\n     *\n     * @param drag - The drag object associated with the action.\n     *\n     * @param currTarget - The current drag target element, or `null`. This\n     *   is the \"current target element\" from the whatwg spec.\n     *\n     * @param event - The mouse event related to the action.\n     *\n     * @returns The `DropAction` result of the drop event.\n     *\n     * #### Notes\n     * This largely implements the drag over portion of the whatwg spec:\n     * https://html.spec.whatwg.org/multipage/interaction.html#drag-and-drop-processing-model\n     */\n    function dispatchDrop(drag, currTarget, event) {\n        // If there is no current target, the drop action is none.\n        if (!currTarget) {\n            return 'none';\n        }\n        // Dispatch the drop event to the current target.\n        let dragEvent = new Drag.Event(event, {\n            drag,\n            related: null,\n            type: 'lm-drop'\n        });\n        let canceled = !currTarget.dispatchEvent(dragEvent);\n        // If the event was canceled, return the drop action result.\n        if (canceled) {\n            return dragEvent.dropAction;\n        }\n        // Otherwise, the effective drop action is none.\n        return 'none';\n    }\n    Private.dispatchDrop = dispatchDrop;\n    /**\n     * A lookup table from drop action to bit value.\n     */\n    const actionTable = {\n        none: 0x0,\n        copy: 0x1,\n        link: 0x2,\n        move: 0x4\n    };\n    /**\n     * A lookup table from supported action to drop action bit mask.\n     */\n    const supportedTable = {\n        none: actionTable['none'],\n        copy: actionTable['copy'],\n        link: actionTable['link'],\n        move: actionTable['move'],\n        'copy-link': actionTable['copy'] | actionTable['link'],\n        'copy-move': actionTable['copy'] | actionTable['move'],\n        'link-move': actionTable['link'] | actionTable['move'],\n        all: actionTable['copy'] | actionTable['link'] | actionTable['move']\n    };\n    /**\n     * Implementation of `Drag.overrideCursor`.\n     */\n    function overrideCursor(cursor, doc = document) {\n        let id = ++overrideCursorID;\n        const body = doc instanceof Document\n            ? doc.body\n            : doc.firstElementChild;\n        if (!Private.cursorBackdrop.isConnected) {\n            // Hide the backdrop until the pointer moves to avoid issues with\n            // native double click detection, used in e.g. datagrid editing.\n            Private.cursorBackdrop.style.transform = 'scale(0)';\n            body.appendChild(Private.cursorBackdrop);\n            resetBackdropScroll();\n            document.addEventListener('pointermove', alignBackdrop, {\n                capture: true,\n                passive: true\n            });\n            Private.cursorBackdrop.addEventListener('scroll', propagateBackdropScroll, {\n                capture: true,\n                passive: true\n            });\n        }\n        Private.cursorBackdrop.style.cursor = cursor;\n        return new DisposableDelegate(() => {\n            if (id === overrideCursorID && Private.cursorBackdrop.isConnected) {\n                document.removeEventListener('pointermove', alignBackdrop, true);\n                Private.cursorBackdrop.removeEventListener('scroll', propagateBackdropScroll, true);\n                body.removeChild(Private.cursorBackdrop);\n            }\n        });\n    }\n    Private.overrideCursor = overrideCursor;\n    /**\n     * Move cursor backdrop to match cursor position.\n     */\n    function alignBackdrop(event) {\n        if (!Private.cursorBackdrop) {\n            return;\n        }\n        Private.cursorBackdrop.style.transform = `translate(${event.clientX}px, ${event.clientY}px)`;\n    }\n    /**\n     * Propagate the scroll event from the backdrop element to the scroll target.\n     * The scroll target is defined by presence of `data-lm-dragscroll` attribute.\n     */\n    function propagateBackdropScroll(_event) {\n        if (!Private.cursorBackdrop) {\n            return;\n        }\n        // Get the element under behind the centre of the cursor backdrop\n        // (essentially behind the cursor, but possibly a few pixels off).\n        let element = findElementBehindBackdrop();\n        if (!element) {\n            return;\n        }\n        // Find scroll target.\n        const scrollTarget = element.closest('[data-lm-dragscroll]');\n        if (!scrollTarget) {\n            return;\n        }\n        // Apply the scroll delta to the correct target.\n        scrollTarget.scrollTop += Private.cursorBackdrop.scrollTop - backdropScrollOrigin;\n        scrollTarget.scrollLeft += Private.cursorBackdrop.scrollLeft - backdropScrollOrigin;\n        // Center the scroll position.\n        resetBackdropScroll();\n    }\n    /**\n     * Reset the backdrop scroll to allow further scrolling.\n     */\n    function resetBackdropScroll() {\n        Private.cursorBackdrop.scrollTop = backdropScrollOrigin;\n        Private.cursorBackdrop.scrollLeft = backdropScrollOrigin;\n    }\n    /**\n     * The center of the backdrop node scroll area.\n     */\n    const backdropScrollOrigin = 500;\n    /**\n     * Create cursor backdrop node.\n     */\n    function createCursorBackdrop() {\n        const backdrop = document.createElement('div');\n        backdrop.classList.add('lm-cursor-backdrop');\n        return backdrop;\n    }\n    /**\n     * The internal id for the active cursor override.\n     */\n    let overrideCursorID = 0;\n    /**\n     * A backdrop node overriding pointer cursor.\n     *\n     * #### Notes\n     * We use a backdrop node rather than setting the cursor directly on the body\n     * because setting it on body requires more extensive style recalculation for\n     * reliable application of the cursor, this is the cursor not being overriden\n     * when over child elements with another style like `cursor: other!important`.\n     */\n    Private.cursorBackdrop = createCursorBackdrop();\n})(Private || (Private = {}));\n\nexport { Drag };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["Private","Drag","constructor","options","this","_onScrollFrame","_scrollTarget","element","edge","distance","d","SCROLL_EDGE_SIZE","f","Math","pow","s","max","round","scrollTop","scrollLeft","requestAnimationFrame","_disposed","_dropAction","_override","_currentTarget","_currentElement","_promise","_resolve","document","mimeData","dragImage","proposedAction","supportedActions","source","dispose","event","PointerEvent","bubbles","cancelable","clientX","clientY","dispatchDragLeave","_finalize","isDisposed","start","Promise","resolve","_addListeners","_attachDragImage","dispatchEvent","handleEvent","type","_evtPointerMove","_evtPointerUp","_evtKeyDown","preventDefault","stopPropagation","moveDragImage","style","transform","_updateCurrentTarget","_updateDragScroll","button","action","dispatchDrop","keyCode","addEventListener","_removeListeners","removeEventListener","target","findScrollTarget","setTimeout","prevTarget","currTarget","prevElem","currElem","findElementBehindBackdrop","dispatchDragExit","dispatchDragEnter","dispatchDragOver","_setDropAction","classList","add","pointerEvents","position","Document","body","firstElementChild","appendChild","_detachDragImage","parent","parentNode","removeChild","validateAction","overrideCursor","clear","Event","DragEvent","super","altKey","ctrlKey","detail","metaKey","relatedTarget","related","screenX","screenY","shiftKey","view","window","drag","dropAction","cursor","doc","root","lastElementEventSearch","cursorBackdrop","zIndex","elementFromPoint","lastElementSearch","bbox","getBoundingClientRect","left","width","top","height","supported","actionTable","supportedTable","x","y","parentElement","hasAttribute","offsetX","offsetY","pageXOffset","pageYOffset","r","right","bottom","dl","dt","dr","db","min","shouldScroll","dsw","scrollWidth","clientWidth","dsh","scrollHeight","clientHeight","dragEvent","none","copy","link","move","all","alignBackdrop","propagateBackdropScroll","_event","scrollTarget","closest","backdropScrollOrigin","resetBackdropScroll","id","overrideCursorID","isConnected","capture","passive","DisposableDelegate","backdrop","createElement","createCursorBackdrop"],"sourceRoot":""}