(function(f,d){typeof exports=="object"&&typeof module<"u"?d(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],d):(f=typeof globalThis<"u"?globalThis:f||self,d(f.trame_vtklocal={},f.Vue))})(this,function(f,d){"use strict";const x="",S=[];function C(c){return new Promise(function(e,n){if(S.indexOf(c)===-1){S.push(c);var t=document.createElement("script");t.type="module",t.src=c,t.onload=e,t.onerror=n,document.body.appendChild(t)}else e(!1)})}class T{constructor(){this.updateInProgress=0,this.loaded=!1,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e){if(this.loaded)return;const n=`${e}/vtkWasmSceneManager.mjs`;await C(n);const t=await window.createVTKWasmSceneManager();t.initialize(),this.loaded=!0,this.sceneManager=t}bindNetwork(e,n,t){this.networkFetchState=e,this.networkFetchHash=n,this.networkFetchStatus=t}freeMemory(e=0){const n=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(n>t){const s={};let i=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([a,l])=>{l<i&&(i=l);const g=l.toString();s[g]?s[g].push(a):s[g]=[a]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const a=s[i];if(a)for(let l=0;l<a.length;l++)this.sceneManager.unRegisterBlob(a[l]),delete this.hashesMTime[a[l]];i++}}}async fetchState(e){const n=await this.networkFetchState(e);return this.patchState(n)}patchState(e){var n;if(e.length>0){const t=JSON.parse(e),{Id:s,MTime:i}=t;return this.stateMTimes[s]=i,this.renderWindowIds.has(s)&&((n=t==null?void 0:t.Interactor)!=null&&n.Id)?(this.renderWindowIdToInteractorId.set(t.Interactor.Id,s),t.CanvasSelector=this.getCanvasSelector(s),delete t.Size,this.renderWindowSizes[s]&&(t.Size=this.renderWindowSizes[s]),t.ClassName="vtkCocoaRenderWindow",JSON.stringify(t)):this.renderWindowIdToInteractorId.has(s)?(t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(s)),JSON.stringify(t)):e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const n=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,n}pushHash(e,n){return this.pendingArrays[e]=new Promise(t=>{n.arrayBuffer?n.arrayBuffer().then(s=>{this.sceneManager.registerBlob(e,new Uint8Array(s)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),t=[],s=[];n.ids.forEach(([a,l])=>{(!this.stateMTimes[a]||this.stateMTimes[a]<l)&&s.push(this.fetchState(a))}),n.hashes.forEach(a=>{this.hashesMTime[a]||t.push(this.fetchHash(a)),this.hashesMTime[a]=this.currentMTime}),n.cameras.forEach(a=>Number(this.cameraIds.add(a))),n.ignore_ids.forEach(a=>this.sceneManager.unRegisterState(a)),await Promise.all(t),await Promise.all(Object.values(this.pendingArrays));const i=await Promise.all(s);for(this.currentMTime++;i.length;){const a=i.pop();a&&this.sceneManager.registerState(a)}try{this.sceneManager.updateObjectsFromStates();const[a,l]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,a,l),this.sceneManager.render(e)}catch(a){console.error("WASM update failed"),console.log(a)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,n=!1){const t=Number(e);return n&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,n=!1){const t=Array.isArray(e)?e:[e];let s=null;for(let i=0;i<t.length;i++){const a=t[i];i===0?s=this.getState(a,n):(s=s[a],s.Id&&(s=this.getState(s.Id,n)))}return s}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,n){const t=this.getCanvasSelector(e);let s=this.offlineCanvasContainer.querySelector(t);return s||(s=document.createElement("canvas"),s.setAttribute("class",t.substring(1)),s.setAttribute("tabindex","0")),n.appendChild(s),t}unbindCanvasToDOM(e){const n=this.getCanvasSelector(e),t=document.querySelector(n);t&&this.offlineCanvasContainer.appendChild(t)}setSize(e,n,t){this.renderWindowSizes[e]=[n,t];const s=this.getCanvasSelector(e),i=document.querySelector(s);i&&(i.width=n,i.height=t,this.sceneManager.setSize(e,n,t),this.sceneManager.render(e))}}function y(c,e,n){return function(){e.clearStateCache();for(const[t,s]of Object.entries(n)){const i={};for(const[a,l]of Object.entries(s))i[a]=e.getStateValue(l,!0);c.state.set(t,i)}e.clearStateCache()}}const b={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera"],props:{renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},listeners:{type:Object}},setup(c,{emit:e}){const n=d.inject("trame"),t=n.state.get("__trame_vtklocal_wasm_url"),s=[],i=[],a=d.ref(null),l=c.wsClient||(n==null?void 0:n.client),g=d.toRef(c,"listeners"),o=new T;let m=null;async function k(r){return await l.getConnection().getSession().call("vtklocal.get.state",[r])}async function I(r){const u=await l.getConnection().getSession().call("vtklocal.get.hash",[r]);return u.arrayBuffer?new Uint8Array(await u.arrayBuffer()):u}async function W(r){return await l.getConnection().getSession().call("vtklocal.get.status",[r])}function A([r]){r.type==="state"&&o.pushState(r.content),r.type==="blob"&&o.pushHash(r.hash,r.content)}async function E(){const r=l.getConnection().getSession();m=r.subscribe("vtklocal.subscriptions",A),await r.call("vtklocal.subscribe.update",[c.renderWindow,1])}async function j(){const r=l.getConnection().getSession();m&&(r.unsubscribe(m),m=null),await r.call("vtklocal.subscribe.update",[c.renderWindow,-1])}function z(){const{width:r,height:h}=a.value.getBoundingClientRect(),u=Math.floor(r*window.devicePixelRatio+.5),M=Math.floor(h*window.devicePixelRatio+.5);o.setSize(c.renderWindow,u,M)}let w=new ResizeObserver(z);function F(){o.freeMemory(c.cacheSize),e("memory-vtk",o.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",o.sceneManager.getTotalBlobMemoryUsage())}async function p(){o.loaded&&(await o.update(c.renderWindow),e("updated"),F())}function N(r){o.sceneManager.resetCamera(r),o.sceneManager.render(c.renderWindow)}d.onMounted(async()=>{o.bindNetwork(k,I,W),await o.load(t);const r=o.bindCanvasToDOM(c.renderWindow,d.unref(a));d.unref(a).querySelector(r).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),c.eagerSync&&E(),w&&w.observe(d.unref(a)),await p(),o.cameraIds.forEach(h=>{s.push([h,o.sceneManager.addObserver(h,"ModifiedEvent",()=>{e("camera",o.getState(h))})])}),d.watchEffect(()=>{for(;i.length;){const[h,u]=i.pop();o.sceneManager.removeObserver(h,u)}for(const[h,u]of Object.entries(g.value||{})){const M=Number(h);for(const[P,R]of Object.entries(u||{})){const v=y(n,o,R);i.push([M,o.sceneManager.addObserver(M,P,v)]),v()}}}),o.sceneManager.startEventLoop(c.renderWindow)}),d.onBeforeUnmount(()=>{for(m&&j();s.length;){const[r,h]=s.pop();o.sceneManager.removeObserver(r,h)}for(;i.length;){const[r,h]=i.pop();o.sceneManager.removeObserver(r,h)}o.sceneManager.stopEventLoop(c.renderWindow),w&&(w.disconnect(),w=null),o.unbindCanvasToDOM(c.renderWindow)});function B(r){y(n,o,r)()}return{container:a,update:p,resetCamera:N,evalStateExtract:B}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function O(c){Object.keys(b).forEach(e=>{c.component(e,b[e])})}f.install=O,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});
