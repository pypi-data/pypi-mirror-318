from typing import List, overload, Any, Union

class BaseTensor:
  storage: List[float]
  shape: List[int] 
  bshape: List[int] 
  nbshape: List[int] 
  hdim: List[int] 
  rank: List[int] 
  size: List[int] 
  bidx: int
  type: str
  dtype: str

  def is_scalar(self) -> bool: ...
  def item(self) -> float: ... 

  def __len__(self) -> int: ...
  def __float__(self) -> float: ...
  def __int__(self) -> int: ...

  # string
  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def meta(self) -> str: ...

  # comparison 
  def __eq__(self, other: object) -> bool: ... 
  def __ne__(self, other: object) -> bool: ... 
  def __lt__(self, other: object) -> bool: ... 
  def __gt__(self, other: object) -> bool: ... 
  def __le__(self, other: object) -> bool: ... 
  def __ge__(self, other: object) -> bool: ... 

  # index 
  def __index__(self) -> int: ...
  def __getitem__(self, indices: Any): ...
  def __setitem__(self, indices: Any, value: Union[float, BaseTensor]): ...

class GradTensor(BaseTensor):
  pidx: int
  type: str
  dtype: str

  # constructor
  @overload
  def __init__(self, scalar: float) -> None: ...
  @overload
  def __init__(self, storage: List[float], shape: List[int], bidx: int, pidx: int) -> None: ...
  @overload
  def __init__(self, shape: List[int], bidx: int, pidx: int) -> None: ...
  @staticmethod
  def eye(n: int, pidx: int = 1) -> 'GradTensor': ...

  # string
  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def meta(self) -> str: ...

  # comparison 
  def __eq__(self, other: object) -> bool: ... 
  def __ne__(self, other: object) -> bool: ... 
  def __lt__(self, other: object) -> bool: ... 
  def __gt__(self, other: object) -> bool: ... 
  def __le__(self, other: object) -> bool: ... 
  def __ge__(self, other: object) -> bool: ... 

  # index 
  def __index__(self) -> int: ...
  def __getitem__(self, indices: Any): ...
  def __setitem__(self, indices: Any, value: Union[float, BaseTensor]): ...

  # shape 
  def shallowcopy(self) -> 'GradTensor': ...
  def deepcopy(self) -> 'GradTensor': ...
  def copy(self) -> 'GradTensor': ...
  def reshape(self) -> 'GradTensor': ...
  @overload
  def transpose(self) -> 'GradTensor': ...
  @overload
  def transpose(self, d1: int, d2: int) -> 'GradTensor': ...
  @overload
  def transpose(self, indices: List[int]) -> 'GradTensor': ...
  @overload
  def T(self) -> 'GradTensor': ...
  @overload
  def T(self, indices: List[int]) -> 'GradTensor': ...

  # algebra
  def __neg__(self) -> 'GradTensor': ... 

  @overload
  def __add__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __add__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: float) -> 'Tensor': ... 
  @overload
  def __radd__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __radd__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __radd__(self, other: float) -> 'Tensor': ... 
 
  @overload
  def __sub__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __sub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: float) -> 'GradTensor': ... 
  @overload
  def __rsub__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __rsub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __rsub__(self, other: float) -> 'GradTensor': ... 

  @overload
  def __mul__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __mul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: float) -> 'GradTensor': ... 
  @overload
  def __rmul__(self, other: 'GradTensor') -> 'GradTensor': ... 
  @overload
  def __rmul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __rmul__(self, other: float) -> 'GradTensor': ... 

  def matmul(self, other: 'GradTensor') -> 'GradTensor': ...
  def __matmul__(self, other: 'GradTensor') -> 'GradTensor': ...

  # math 
  def batchsum(self) -> 'GradTensor': ...

class Tensor(BaseTensor):
  prev: List['Tensor']
  requires_grad: bool 
  grad: GradTensor
  type: str
  dtype: str

  def backprop(self, intermediate: bool = False) -> List['Tensor']: ...

  # constructor
  @overload
  def __init__(self, scalar: float, requires_grad: bool = True) -> None: ... 
  
  @overload
  def __init__(
    self, 
    storage: List[float], 
    shape: List[int], 
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> None: ...
  
  @overload
  def __init__(
    self, 
    storage: List[float], 
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> None: ...

  @overload
  def __init__(
    self, 
    storage: List[List[float]], 
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> None: ...

  @overload
  def __init__(
    self, 
    storage: List[List[List[float]]],
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> None: ...
  
  @staticmethod
  def arange(
    start: int, 
    stop: int, 
    step: int = 1,
    requires_grad: bool = True
  ) -> 'Tensor': ...

  @staticmethod
  def linspace(
    start: float, 
    stop: float, 
    numsteps: int, 
    requires_grad: bool = True
  ) -> 'Tensor': ...

  @staticmethod
  def gaussian(
    shape: List[int], 
    mean: float = 0.0, 
    stddev: float = 1.0, 
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> 'Tensor': ...

  @staticmethod
  def uniform(
    shape: List[int], 
    min: float = 0.0, 
    max: float = 1.0, 
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> 'Tensor': ...

  @staticmethod
  def ones(
    shape: List[int],
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> 'Tensor': ...

  @staticmethod
  def zeros(
    shape: List[int],
    bidx: int = 0, 
    requires_grad: bool = True
  ) -> 'Tensor': ...

  # string
  def __str__(self) -> str: ...
  def __repr__(self) -> str: ...
  def meta(self) -> str: ...

  # comparison 
  def __eq__(self, other: object) -> bool: ... 
  def __ne__(self, other: object) -> bool: ... 
  def __lt__(self, other: object) -> bool: ... 
  def __gt__(self, other: object) -> bool: ... 
  def __le__(self, other: object) -> bool: ... 
  def __ge__(self, other: object) -> bool: ... 

  # index 
  def __index__(self) -> int: ...
  def __getitem__(self, indices: Any): ...
  def __setitem__(self, indices: Any, value: Union[float, BaseTensor]): ...

  # shape
  def shallowcopy(self) -> 'Tensor': ...
  def deepcopy(self) -> 'Tensor': ...
  def copy(self) -> 'Tensor': ...
  def reshape(self, new_shape: List[int]) -> 'Tensor': ...
  @overload
  def transpose(self) -> 'Tensor': ...
  @overload
  def transpose(self, indices: List[int]) -> 'Tensor': ...
  @overload
  def T(self) -> 'Tensor': ...
  @overload
  def T(self, indices: List[int]) -> 'Tensor': ...

  # algebra
  def __neg__(self) -> 'Tensor': ...   
  @overload
  def __add__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __add__(self, other: float) -> 'Tensor': ... 
  @overload
  def __radd__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __radd__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __radd__(self, other: float) -> 'Tensor': ... 

  @overload
  def __sub__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __sub__(self, other: float) -> 'Tensor': ... 
  @overload
  def __rsub__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __rsub__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __rsub__(self, other: float) -> 'Tensor': ... 

  @overload
  def __mul__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __mul__(self, other: float) -> 'Tensor': ...  
  @overload
  def __rmul__(self, other: 'GradTensor') -> 'Tensor': ... 
  @overload
  def __rmul__(self, other: 'Tensor') -> 'Tensor': ... 
  @overload
  def __rmul__(self, other: float) -> 'Tensor': ...  

  def __pow__(self, exp: float) -> "Tensor": ...

  def matmul(self, other: 'Tensor') -> 'Tensor': ...
  def __matmul__(self, other: 'Tensor') -> 'Tensor': ...

  # math
  def sum(self) -> 'Tensor': ... 
  def relu(self)-> 'Tensor': ...
  def dot(self, other: 'Tensor') -> 'Tensor': ...
