Prodfile
--------------

Prodfile is a Python script that defines build rules and dependencies for the PyProd build system. It is used to specify how to build a project, including the source files, build targets, and the rules to generate the targets.



Rule definition
^^^^^^^^^^^^^^^^^^

A rule is defined using the ``@rule`` decorator, which takes the target file as an argument. The target file is the output of the rule, and the function that follows the decorator is the build logic that generates the target file.

.. py:function:: @rule(target, pattern=None, depends=(), uses=())

   Defines rule to build target files.

   :param target: The target file or files to be generated by the rule. Wildcards can be used in filenames, and exactly one % must be included in the filename.
   :type target: str|Path|list[str|Path]

   :param pattern: Specify the pattern used to extract the stem of the target filename.

   :type pattern: str|Path|None

   :param depends: Specify the dependencies of the target file. The target file will be rebuilt if any of the dependencies are newer than the target file.
   :type depends: str|Path|list[str|Path]

   :param uses: Specify the dependencies of the target file. Unlike the ``depends`` parameter, the target file will not be rebuilt if any of the dependencies are newer than the target file.
   :type uses: str|Path|list[str|Path]

Build function
~~~~~~~~~~~~~~~~~~~
The first argument of the decorated function specifies the target file to be generated. The target can be a string or a Path object, depending on the value provided in the target parameter. Subsequent arguments correspond to the filenames listed in the depends parameter. The rule function must accept the target and the same number of arguments as those specified in depends.

For example, the following code prints ``file1 ['file2', 'file3']`` when the target file ``file1`` is built:

.. code-block:: python

   @rule("file1", depends=("file2", "file3"), uses=("file4", "file5"))
   def builds(target, *deps):
       print(target, deps)

Pattern
~~~~~~~~~~

A pattern is a filename template that uses ``%`` as a wildcard to match any string. The portion of the target matched by ``%`` is called the stem, which is used to substitute ``%`` in dependencies. For example, in the following rule, a ``*.o`` file is built from the corresponding ``*.c`` file sharing the same stem.

.. code-block:: python

   @rule("%.o", depends="%.c")
   def builds(target, src):
       print(target, src)

If ``%`` cannot be used directly in the target, you can use the pattern argument to extract the stem. For example, the following rule builds ``dir1/file1.o`` from ``dir1/file1.c``:

.. code-block:: python

   @rule("dir1/file1.o", pattern="%.o", depends="%.c")
   def build(target, src):
       print(target, src)


Flattening Dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sequences specified for ``target``, ``depends``, and ``uses`` are automatically flattened, so there's no need to manually concatenate lists.

For example, the following code is equivalent to the previous example:

.. code-block:: python

   @rule(["file1"], depends=["file2", ["file3"]], uses=[["file4", ["file5"]]])
   def builds(target, *deps):
      print(target, deps)

Using rule as a Standalone Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The rule decorator can also be used as a standalone function without being tied to a specific function. This makes it convenient for specifying dependencies for multiple targets. For example:

.. code-block:: python

   rule(target=("file1", "file2"), depends="inc1")
   rule(target=("file3", "file4"), uses="inc2")




Checker definition
^^^^^^^^^^^^^^^^^^

A checker is defined using the ``@check`` decorator, which takes the target file as an argument. The checker tests if the target is exists or not.

.. py:function:: @check(target)

   Defines a checker to get last modified time of the target.

   :param target: The target file to be checked. Wildcards can be used.
   :type target: str|Path

   :return: Last modified time of the file if the target exists. Returns false or raise FileNotFoundError if the target does not exist.
   :rtype: false|float|datetime.datetime

PyProd provides default checkers for common file types for files and directories. 
PyProd includes default checkers for common file types, applicable to both files and directories. For non-file targets requiring specialized checks, you can define a custom checker to determine whether a build is needed.

For example, a checker to retrieve the last modified timestamp of a file on Amazon S3 can be defined as follows:

.. code-block:: python

   import re, boto3, botocore
   s3 = boto3.client("s3")
   
   # Returns bucket and key from s3 URL
   def parse_s3url(url):
       return re.match(r"s3://([^/]+)/(.+)", url).groups()
   
   # Builds s3://bucket/key/file.txt if data.txt is newer 
   @rule("s3://TESTBUCKET/key/file.txt", depends="data.txt")
   def build_s3file(target, src):
       bucket, key = parse_s3url(target)
       s3.upload_file(src, Bucket=bucket, Key=key)
   
   # This checker matches "s3://bucket/key/file.txt"
   @check("s3://*")
   def check_s3file(target):
       """Checks if an S3 file exists. Returns timestamp if it does."""
       bucket, key = parse_s3url(target)
       try:
          return s3.head_object(Bucket=bucket, Key=key)["LastModified"]
       except botocore.exceptions.ClientError as e:
          if e.response["Error"]["Code"] == "404":
              return
          raise
   



Built-in Functions/Variables
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In addition to the ``@rule`` and ``@check`` decorators, PyProd provides several other built-in functions that can be used without importing them. These functions are designed to facilitate various aspects of the build process.

The following built-ins are available:


.. py:function:: pip(*args)

   Install Python packages. It creates a virtual environment if one does not already exist and installs the specified packages.
   
   :param args: Arguments to pass to the pip install command.
   :type target: str

Example:

.. code-block:: python
   
   pip("numpy", "pandas")

.. _run:

.. py:function:: run(*args, echo=True, shell=None, stdout=None,cwd=None, text=True,    check=True)

   Execute a command. This function is a wrapper around `subprocess.run()` and provides additional functionality for the build system.

   :param args: Command and arguments to execute. If first argument is a list, the first element is the command and the rest are arguments. Sequences specified for args are automatically flattened.
   :type args: str|Path|list[str|Path]

   :echo: Print the command before executing it (default ``True``).
   :type echo: bool

   :shell: Run the command in a shell. If None, the shell is used unless `arg` is sequence (default ``None``).
   :type shell: bool|None

   :stdout: Capture the output of the command (default ``False``).
   :type shell: bool

   :cwd: Change the current working directory before executing the command.
   :type shell: str|Path|None

   :param text: Use text mode for stdout and stderr (default ``True``).
   :type shell: bool
   
   :param check: Raise an exception if the command returns a non-zero exit code (default ``True``).
   :type shell: bool
   
   :return: Returns instance of `CompletedProcess <https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess>`_.


   Examples:
   
   .. code-block:: python
   
      run(["echo", "Hello, World!"]) # list style args
      run(["echo Hello, World"]) # Shell style args
      run(["echo", "Hello,", "World"]) # Shell style args (automactic concatenation)
      run("echo", ["hello", ["world"]]) # Shell style args (automactic flattening)
   
      files = run("ls", stdout=True).stdout # Capture output
   
   
.. py:function:: def capture(*args, echo=True, cwd=None, check=True, text=True, shell=None)

   Execute a command and capture the output. This function is a wrapper around 
   :ref:`run <run>`.

   :param args: Command and arguments to execute. If first argument is a list, the first element is the command and the rest are arguments. Sequences specified for args are automatically flattened.
   :type args: str|Path|list[str|Path]

   :echo: Print the command before executing it (default ``True``).
   :type echo: bool

   :cwd: Change the current working directory before executing the command.
   :type shell: str|Path|None

   :param check: Raise an exception if the command returns a non-zero exit code (default ``True``).
   :type shell: bool

   :param text: Use text mode for stdout and stderr (default ``True``).
   :type shell: bool

   :param shell: Run the command in a shell. If None, the shell is used unless `arg` is sequence (default ``None``).
   :type shell: bool

   :return: Returns the output of the command as a string. Trimmed of trailing newline.

   Examples:
   
   .. code-block:: python
   
      msg = capture("echo Hello, World!")
   

.. py:function::  glob(path, dir=".")

   Glob the given relative pattern in the directory represented by this path. This function is a wrapper around `pathlib.Path.glob() <https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob>`_. Unlike ``pathlib.Path.glob()``, this function ignores files and directlies that start with a dot. Also, this function returns a list of Path objects.

   :param path: The file pattern to match.
   :type path: str|Path

   :param dir: The directory to search in (default ``.``).
   :type dir: str|Path

   :return: A list of Path object.
   :rtype: list[Path]


   Examples:
   
   .. code-block:: python
   
      SRCFILES = glob("**/*.c")
   
.. py:function::  quote(s)

   Quote a string for use as a shell command argument. This function is a wrapper around `shlex.quote() <https://docs.python.org/3/library/shlex.html#shlex.quote>`_.

   :param s: The string to quote.
   :type s: str

   :return: The quoted string.
   :rtype: str

.. py:class::  Path
   
   A class representing file paths. This function is an alias for `pathlib.Path <https://docs.python.org/3/library/pathlib.html#pathlib.Path>`_.

   :return: A Path object.
   :rtype: Path

.. py:data::  shutil

   Module to perform high-level file operations. See `shutil <https://docs.python.org/3/library/shutil.html>`_ for detail.


.. py:data:: env
   
   A dictionary that holds environment variables. You can also access values using dot notation, like env.NAME. Unlike os.environ, env returns an empty string ("") if a variable is not set. 

   Examples:
   
   .. code-block:: python
   
      print(env["UNKNOWN_ENV_VAR"]) # prints ""
      print(env.PATH) # prints the value of the PATH environment variable
      env.VAR = "value" # sets the value of the VAR environment variable


.. _params:

.. py:data:: params
   
   A dictionary that holds variables passed from the :ref:`Command line options<commandline>`. You can also access values using dot notation, like params.NAME. params returns an empty string ("") if a variable is not set. 

   Examples:
   
   .. code-block:: python
   
      print(params["UNKNOWN_ENV_VAR"]) # prints ""
      print(env.PATH) # prints the value of the PATH environment variable
      env.VAR = "value" # sets the value of the VAR environment variable
   


.. py:data::  MAX_TS

   A constant representing the maximum timestamp. This value can be is used to force a target to be rebuilt.

