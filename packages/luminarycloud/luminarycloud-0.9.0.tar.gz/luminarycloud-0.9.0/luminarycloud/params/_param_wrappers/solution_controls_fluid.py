# Generated by generate_sdk_wrappers.py. DO NOT EDIT

from abc import ABCMeta
from dataclasses import dataclass, field
from typing import Any, Optional
from uuid import uuid4

from luminarycloud.tables import RectilinearTable
from luminarycloud.types import Vector3
from luminarycloud._proto.client import simulation_pb2 as clientpb
from luminarycloud._proto.client.entity_pb2 import EntityIdentifier
import luminarycloud.params.enum._enum_wrappers as enum

from ._lib import ParamGroupWrapper, create_unique_id

from .amg_params import AmgParams
from .cfl_based import CflBased
from .fixed_pseudo_time_step import FixedPseudoTimeStep
from .fluid_explicit_relaxation import FluidExplicitRelaxation
from .fluid_implicit_relaxation import FluidImplicitRelaxation
from .fluid_relaxation_method import FluidRelaxationMethod
from .gauss_seidel import GaussSeidel
from .krylov_amg import KrylovAmg
from .linear_solver_type import LinearSolverType
from .pseudo_time_step_method import PseudoTimeStepMethod
from .robust_startup import RobustStartup
from .robust_startup_off import RobustStartupOff
from .robust_startup_on import RobustStartupOn


@dataclass(kw_only=True)
class SolutionControlsFluid(ParamGroupWrapper[clientpb.SolutionControlsFluid]):
    """Solution controls for a fluid flow physics solver."""

    pseudo_time_step_method: PseudoTimeStepMethod = field(default_factory=CflBased)
    "Method for obtaining the pseudo time step in a steady-state simulation or for the inner iterations of the dual time stepping method."
    fluid_relaxation_method: FluidRelaxationMethod = field(default_factory=FluidImplicitRelaxation)
    "Relaxation scheme for steady-state simulations or time implicit transient simulations."

    def _to_proto(self) -> clientpb.SolutionControlsFluid:
        _proto = clientpb.SolutionControlsFluid()
        if isinstance(self.pseudo_time_step_method, CflBased):
            _proto.pseudo_time_step_method = clientpb.CFL_BASED
            _proto.cfl.value = self.pseudo_time_step_method.cfl
        if isinstance(self.pseudo_time_step_method, FixedPseudoTimeStep):
            _proto.pseudo_time_step_method = clientpb.FIXED_PSEUDO_TIME_STEP
            _proto.pseudo_time_step_val.value = self.pseudo_time_step_method.pseudo_time_step
        if isinstance(self.fluid_relaxation_method, FluidImplicitRelaxation):
            _proto.relaxation_method = clientpb.IMPLICIT
            _proto.implicit_method = self.fluid_relaxation_method.implicit_method
            _proto.linsol_iterations.value = (
                self.fluid_relaxation_method.linear_solver_type.iterations
            )
            _proto.linsol_tolerance.value = (
                self.fluid_relaxation_method.linear_solver_type.tolerance
            )
            if isinstance(self.fluid_relaxation_method.linear_solver_type, GaussSeidel):
                _proto.linear_solver_type = clientpb.GS
            if isinstance(self.fluid_relaxation_method.linear_solver_type, KrylovAmg):
                _proto.linear_solver_type = clientpb.AMG_KRYLOV_AMGX
                _proto.linsol_amg_pre_sweeps.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.pre_sweeps
                )
                _proto.linsol_amg_post_sweeps.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.post_sweeps
                )
                _proto.linsol_amg_coarsening_size.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.coarsening_size
                )
                _proto.linsol_amg_levels.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.levels
                )
                _proto.linsol_amg_relaxation.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.relaxation
                )
                _proto.linsol_amg_cycle_type = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.multigrid_cycle
                )
                _proto.linsol_amg_freeze_levels_threshold.value = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.freeze_levels_threshold
                )
                _proto.linsol_amg_smoother = (
                    self.fluid_relaxation_method.linear_solver_type.amg_params.smoother
                )
            _proto.jacobian_update_method = self.fluid_relaxation_method.jacobian_update_method
            _proto.jacobian_update_interval.value = (
                self.fluid_relaxation_method.jacobian_update_interval
            )
            _proto.jacobian_warmup_threshold.value = (
                self.fluid_relaxation_method.jacobian_warmup_threshold
            )
            if isinstance(self.fluid_relaxation_method.robust_startup, RobustStartupOn):
                _proto.robust_startup = clientpb.ROBUST_STARTUP_ON
                _proto.robust_startup_initial_cfl.value = (
                    self.fluid_relaxation_method.robust_startup.robust_startup_initial_cfl
                )
                _proto.robust_startup_iterations.value = (
                    self.fluid_relaxation_method.robust_startup.robust_startup_iterations
                )
            if isinstance(self.fluid_relaxation_method.robust_startup, RobustStartupOff):
                _proto.robust_startup = clientpb.ROBUST_STARTUP_OFF
            _proto.relax_flow.value = self.fluid_relaxation_method.relaxation_flow
            _proto.relax_turb.value = self.fluid_relaxation_method.relaxation_turb
            _proto.update_limit_flow.value = self.fluid_relaxation_method.update_limit_flow
            _proto.update_limit_turb.value = self.fluid_relaxation_method.update_limit_turb
        if isinstance(self.fluid_relaxation_method, FluidExplicitRelaxation):
            _proto.relaxation_method = clientpb.EXPLICIT
            _proto.explicit_method = self.fluid_relaxation_method.explicit_method
        return _proto

    def _from_proto(self, proto: clientpb.SolutionControlsFluid) -> None:
        if proto.pseudo_time_step_method == clientpb.INVALID_PSEUDO_TIME_STEP_METHOD:
            raise ValueError("Invalid pseudo_time_step_method")
        elif proto.pseudo_time_step_method == clientpb.CFL_BASED:
            self.pseudo_time_step_method = CflBased()
            self.pseudo_time_step_method.cfl = proto.cfl.value
        elif proto.pseudo_time_step_method == clientpb.FIXED_PSEUDO_TIME_STEP:
            self.pseudo_time_step_method = FixedPseudoTimeStep()
            self.pseudo_time_step_method.pseudo_time_step = proto.pseudo_time_step_val.value
        if proto.relaxation_method == clientpb.INVALID_RELAXATION_METHOD:
            raise ValueError("Invalid fluid_relaxation_method")
        elif proto.relaxation_method == clientpb.IMPLICIT:
            self.fluid_relaxation_method = FluidImplicitRelaxation()
            self.fluid_relaxation_method.implicit_method = enum.ImplicitMethod(
                proto.implicit_method
            )
            self.fluid_relaxation_method.linear_solver_type.iterations = (
                proto.linsol_iterations.value
            )
            self.fluid_relaxation_method.linear_solver_type.tolerance = proto.linsol_tolerance.value
            if proto.linear_solver_type == clientpb.INVALID_LINEAR_SOLVER_TYPE:
                raise ValueError("Invalid linear_solver_type")
            elif proto.linear_solver_type == clientpb.GS:
                self.fluid_relaxation_method.linear_solver_type = GaussSeidel()
            elif proto.linear_solver_type == clientpb.AMG_KRYLOV_AMGX:
                self.fluid_relaxation_method.linear_solver_type = KrylovAmg()
                self.fluid_relaxation_method.linear_solver_type.amg_params.pre_sweeps = (
                    proto.linsol_amg_pre_sweeps.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.post_sweeps = (
                    proto.linsol_amg_post_sweeps.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.coarsening_size = (
                    proto.linsol_amg_coarsening_size.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.levels = (
                    proto.linsol_amg_levels.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.relaxation = (
                    proto.linsol_amg_relaxation.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.multigrid_cycle = (
                    enum.LinsolAmgCycleType(proto.linsol_amg_cycle_type)
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.freeze_levels_threshold = (
                    proto.linsol_amg_freeze_levels_threshold.value
                )
                self.fluid_relaxation_method.linear_solver_type.amg_params.smoother = (
                    enum.LinsolAmgSmoother(proto.linsol_amg_smoother)
                )
            self.fluid_relaxation_method.jacobian_update_method = enum.JacobianUpdateMethod(
                proto.jacobian_update_method
            )
            self.fluid_relaxation_method.jacobian_update_interval = (
                proto.jacobian_update_interval.value
            )
            self.fluid_relaxation_method.jacobian_warmup_threshold = (
                proto.jacobian_warmup_threshold.value
            )
            if proto.robust_startup == clientpb.INVALID_ROBUST_STARTUP:
                raise ValueError("Invalid robust_startup")
            elif proto.robust_startup == clientpb.ROBUST_STARTUP_ON:
                self.fluid_relaxation_method.robust_startup = RobustStartupOn()
                self.fluid_relaxation_method.robust_startup.robust_startup_initial_cfl = (
                    proto.robust_startup_initial_cfl.value
                )
                self.fluid_relaxation_method.robust_startup.robust_startup_iterations = (
                    proto.robust_startup_iterations.value
                )
            elif proto.robust_startup == clientpb.ROBUST_STARTUP_OFF:
                self.fluid_relaxation_method.robust_startup = RobustStartupOff()
            self.fluid_relaxation_method.relaxation_flow = proto.relax_flow.value
            self.fluid_relaxation_method.relaxation_turb = proto.relax_turb.value
            self.fluid_relaxation_method.update_limit_flow = proto.update_limit_flow.value
            self.fluid_relaxation_method.update_limit_turb = proto.update_limit_turb.value
        elif proto.relaxation_method == clientpb.EXPLICIT:
            self.fluid_relaxation_method = FluidExplicitRelaxation()
            self.fluid_relaxation_method.explicit_method = enum.ExplicitMethod(
                proto.explicit_method
            )
        return None
