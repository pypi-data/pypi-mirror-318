# Generated by generate_sdk_wrappers.py. DO NOT EDIT

from abc import ABCMeta
from dataclasses import dataclass, field
from typing import Any, Optional
from uuid import uuid4

from luminarycloud.tables import RectilinearTable
from luminarycloud.types import Vector3
from luminarycloud._proto.client import simulation_pb2 as clientpb
from luminarycloud._proto.client.entity_pb2 import EntityIdentifier
import luminarycloud.params.enum._enum_wrappers as enum

from ._lib import ParamGroupWrapper, create_unique_id

from .amg_params import AmgParams
from .gauss_seidel import GaussSeidel
from .heat_implicit_relaxation import HeatImplicitRelaxation
from .heat_relaxation_method import HeatRelaxationMethod
from .krylov_amg import KrylovAmg
from .linear_solver_type import LinearSolverType


@dataclass(kw_only=True)
class SolutionControlsHeat(ParamGroupWrapper[clientpb.SolutionControlsHeat]):
    """Solution controls for a heat transfer physics solver."""

    heat_relaxation_method: HeatRelaxationMethod = field(default_factory=HeatImplicitRelaxation)
    "Relaxation scheme for steady-state simulations or time implicit transient simulations."

    def _to_proto(self) -> clientpb.SolutionControlsHeat:
        _proto = clientpb.SolutionControlsHeat()
        if isinstance(self.heat_relaxation_method, HeatImplicitRelaxation):
            _proto.relaxation_method = clientpb.IMPLICIT
            _proto.implicit_method = self.heat_relaxation_method.implicit_method
            _proto.linsol_iterations.value = (
                self.heat_relaxation_method.linear_solver_type.iterations
            )
            _proto.linsol_tolerance.value = self.heat_relaxation_method.linear_solver_type.tolerance
            if isinstance(self.heat_relaxation_method.linear_solver_type, GaussSeidel):
                _proto.linear_solver_type = clientpb.GS
            if isinstance(self.heat_relaxation_method.linear_solver_type, KrylovAmg):
                _proto.linear_solver_type = clientpb.AMG_KRYLOV_AMGX
                _proto.linsol_amg_pre_sweeps.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.pre_sweeps
                )
                _proto.linsol_amg_post_sweeps.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.post_sweeps
                )
                _proto.linsol_amg_coarsening_size.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.coarsening_size
                )
                _proto.linsol_amg_levels.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.levels
                )
                _proto.linsol_amg_relaxation.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.relaxation
                )
                _proto.linsol_amg_cycle_type = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.multigrid_cycle
                )
                _proto.linsol_amg_freeze_levels_threshold.value = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.freeze_levels_threshold
                )
                _proto.linsol_amg_smoother = (
                    self.heat_relaxation_method.linear_solver_type.amg_params.smoother
                )
        return _proto

    def _from_proto(self, proto: clientpb.SolutionControlsHeat) -> None:
        if proto.relaxation_method == clientpb.INVALID_RELAXATION_METHOD:
            raise ValueError("Invalid heat_relaxation_method")
        elif proto.relaxation_method == clientpb.IMPLICIT:
            self.heat_relaxation_method = HeatImplicitRelaxation()
            self.heat_relaxation_method.implicit_method = enum.ImplicitMethod(proto.implicit_method)
            self.heat_relaxation_method.linear_solver_type.iterations = (
                proto.linsol_iterations.value
            )
            self.heat_relaxation_method.linear_solver_type.tolerance = proto.linsol_tolerance.value
            if proto.linear_solver_type == clientpb.INVALID_LINEAR_SOLVER_TYPE:
                raise ValueError("Invalid linear_solver_type")
            elif proto.linear_solver_type == clientpb.GS:
                self.heat_relaxation_method.linear_solver_type = GaussSeidel()
            elif proto.linear_solver_type == clientpb.AMG_KRYLOV_AMGX:
                self.heat_relaxation_method.linear_solver_type = KrylovAmg()
                self.heat_relaxation_method.linear_solver_type.amg_params.pre_sweeps = (
                    proto.linsol_amg_pre_sweeps.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.post_sweeps = (
                    proto.linsol_amg_post_sweeps.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.coarsening_size = (
                    proto.linsol_amg_coarsening_size.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.levels = (
                    proto.linsol_amg_levels.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.relaxation = (
                    proto.linsol_amg_relaxation.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.multigrid_cycle = (
                    enum.LinsolAmgCycleType(proto.linsol_amg_cycle_type)
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.freeze_levels_threshold = (
                    proto.linsol_amg_freeze_levels_threshold.value
                )
                self.heat_relaxation_method.linear_solver_type.amg_params.smoother = (
                    enum.LinsolAmgSmoother(proto.linsol_amg_smoother)
                )
        return None
