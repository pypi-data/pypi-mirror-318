# generated by mBlock5 for CyberPi
# codes make you happy

import event, time, cyberpi, mbuild, event, time, cyberpi, mbot2, math,global_objects, uos, math, mbot2, mbuild, gamepad, time, event, math, mbot2, mbuild, cyberpi, gamepad, cyberpi, mbot2, math,global_objects, uos, mbuild, event, time,  gamepad, mbot2, mbuild, event, time, cyberpi, math, gamepad, event, time, cyberpi, mbuild, mbot2, event, time
# initialize variables
from system.sys_loop import sys_loop_add_operation, sys_loop_delete_operation
from neurons_protocol.neurons_engine import neurons_request
from utility.common import num_range_scale
angle_to = [None, None]
calibration_gain = 1.80

encode_curerent_angle = [0, 0]
gyro_z_offset = 0
mbot2_param_init = 0
get_value  = None
cur_config = None
CONFIG_FILE_PATH = "_config.py"

MBOT2_CONFIG = \
{
    "mbot2_correction":"0000",
    "mbot2_gyro_z_offset":0,
    "mbot2_calibration_gain":1.80,
    "mbot_wsdsa":0,
}

def __write_mbot2_config():
    uos.chdir('/flash')
    with open(CONFIG_FILE_PATH, "w") as f:
        f.write(str(MBOT2_CONFIG))

def read_config(key=None):
    global cur_config
    uos.chdir('/flash')
    if not (CONFIG_FILE_PATH in uos.listdir()):
        __write_mbot2_config()
        cur_config = MBOT2_CONFIG
    else:
        try:
            with open(CONFIG_FILE_PATH, "r") as f:
                cur_config = eval(f.read())
        except Exception as e:
            __write_mbot2_config()
            cur_config = MBOT2_CONFIG

    if key == None:
        return cur_config
    else:
        if key in cur_config:
            return cur_config[key]

def write_config(key,value):
    global cur_config
    cur_config = read_config()
    uos.chdir('/flash')
    cur_config[key] = value
    with open(CONFIG_FILE_PATH, "w") as f:
        f.write(str(cur_config))

def get_mot2_memory(key):
    global get_value
    def store_name():
        global get_value
        get_value = read_config(str(key))
    handle = sys_loop_add_operation(store_name, ())
    handle.run("once", wait_flag = True)
    sys_loop_delete_operation(handle)
    return get_value

from system.sys_loop import sys_loop_add_operation, sys_loop_delete_operation
from neurons_protocol.neurons_engine import neurons_request
from utility.common import num_range_scale
angle_to = [None, None]
calibration_gain = 1.80

encode_curerent_angle = [0, 0]
gyro_z_offset = 0
mbot2_param_init = 0
get_value  = None
cur_config = None
CONFIG_FILE_PATH = "_config.py"

MBOT2_CONFIG = \
{
    "mbot2_correction":"0000",
    "mbot2_gyro_z_offset":0,
    "mbot2_calibration_gain":1.80,
    "mbot_wsdsa":0,
}

def __write_mbot2_config():
    uos.chdir('/flash')
    with open(CONFIG_FILE_PATH, "w") as f:
        f.write(str(MBOT2_CONFIG))

def read_config(key=None):
    global cur_config
    uos.chdir('/flash')
    if not (CONFIG_FILE_PATH in uos.listdir()):
        __write_mbot2_config()
        cur_config = MBOT2_CONFIG
    else:
        try:
            with open(CONFIG_FILE_PATH, "r") as f:
                cur_config = eval(f.read())
        except Exception as e:
            __write_mbot2_config()
            cur_config = MBOT2_CONFIG

    if key == None:
        return cur_config
    else:
        if key in cur_config:
            return cur_config[key]

def write_config(key,value):
    global cur_config
    cur_config = read_config()
    uos.chdir('/flash')
    cur_config[key] = value
    with open(CONFIG_FILE_PATH, "w") as f:
        f.write(str(cur_config))

def set_mot2_memory(key,value):
    def store_name():
        write_config(str(key),int(value))
    handle = sys_loop_add_operation(store_name, ())
    handle.run("once", wait_flag = True)
    sys_loop_delete_operation(handle)

def cross_line(speed_cross, code_cross, leixing, kp_cross, ki_cross, kd_cross):
    global error_pid, error_acc, last_e_pid, D_pid, I_pid, PID
    PID = 0
    I_pid = 0
    D_pid = 0
    if leixing == 1:
      while not ((mbuild.quad_rgb_sensor.is_line("L2",1)) and (mbuild.quad_rgb_sensor.is_line("R2",1))):
        pid_line(speed_cross, kp_cross, ki_cross, kd_cross)

    else:
      if leixing == 2:
        while not ((mbuild.quad_rgb_sensor.is_line("L1",1)) and (mbuild.quad_rgb_sensor.is_line("L2",1))):
          pid_line(speed_cross, kp_cross, ki_cross, kd_cross)

      else:
        if leixing == 3:
          while not ((mbuild.quad_rgb_sensor.is_line("R1",1)) and (mbuild.quad_rgb_sensor.is_line("R2",1))):
            pid_line(speed_cross, kp_cross, ki_cross, kd_cross)
    B_motor_code______left_speed_N_right_speed_N_degree12_N (speed_cross, speed_cross,code_cross)
def code_line(speed_c, code_c, kp_c, ki_c, kd_c):
    global error_pid, error_acc, last_e_pid, D_pid, I_pid, PID
    mbot2.EM_reset_angle("ALL")
    PID = 0
    I_pid = 0
    D_pid = 0
    while not (math.fabs(mbot2.EM_get_angle("EM1")) > code_c or math.fabs(mbot2.EM_get_angle("EM2")) > code_c):
      pid_line(speed_c, kp_c, ki_c, kd_c)
def catch_line ():
    global LEFT, RIGHT, KP, KI, KD, _E5_BE_AE_E5_88_86, _E7_A7_AF_E5_88_86, _E8_AF_AF_E5_B7_AE, _E4_B8_8A_E4_B8_80_E6_AC_A1_E8_AF_AF_E5_B7_AE, _E8_84_89_E5_86_B2, g_kp, g_ki, g_kd, g_pwm, g_le, _E6_AC_A1_E6_95_B0, _E5_88_A4_E6_96_AD, X, Y, slope, y, z, n, red, error2, POWER2, j, speed_a, _E4_BB_BB_E5_8A_A1, _E4_BB_BB_E5_8A_A1_E4_BA_8C_E8_93_9D_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BD_8D_E7_BD_AE_E4_BA_8C_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BB_BB_E5_8A_A1_E4_B8_89_E8_88_B5_E6_9C_BA_E5_BC_A0_E5_BC_80_E7_9A_84_E8_A7_92_E5_BA_A6, _E4_BB_BB_E5_8A_A1_E4_B8_89_E5_A4_B9_E6_96_B9_E5_9D_97_E5_90_8E_E9_80_80_E8_B7_9D_E7_A6_BB, Y1, X1, my_1, my_2, _E6_91_87_E6_9D_86_E7_B3_BB_E6_95_B0, step, u, _E4_BD_8D_E7_BD_AE_E4_B8_80_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, spxxx, spxxs, g_eer, g_ii, g_dd, tong, factor_speed, skp
    _E6_AC_A1_E6_95_B0 = 0
    _E5_88_A4_E6_96_AD = 0
    while not _E6_AC_A1_E6_95_B0 > 30:
        mbot2.drive_speed(50, 50)
        _E6_AC_A1_E6_95_B0 = _E6_AC_A1_E6_95_B0 + 1
        if (mbuild.quad_rgb_sensor.is_line("R1",1)) or (mbuild.quad_rgb_sensor.is_line("L1",1)):
            _E6_AC_A1_E6_95_B0 = 31
            _E5_88_A4_E6_96_AD = 1

    _E6_AC_A1_E6_95_B0 = 0
    if _E5_88_A4_E6_96_AD == 0:
        while not _E6_AC_A1_E6_95_B0 > 60:
            mbot2.drive_speed(-50, -50)
            _E6_AC_A1_E6_95_B0 = _E6_AC_A1_E6_95_B0 + 1
            if (mbuild.quad_rgb_sensor.is_line("R1",1)) or (mbuild.quad_rgb_sensor.is_line("L1",1)):
                _E6_AC_A1_E6_95_B0 = 61

    mbot2.EM_stop("ALL")
    time.sleep(0.1)
    KP = 0.4
    KI = 0.001
    KD = 0.2
    cyberpi.timer.reset()
    while not (cyberpi.timer.get() > 0.3 or mbuild.quad_rgb_sensor.get_offset_track(1) == 0):
        _E8_AF_AF_E5_B7_AE = mbuild.quad_rgb_sensor.get_offset_track(1)
        _E5_BE_AE_E5_88_86 = (_E5_BE_AE_E5_88_86 + _E8_AF_AF_E5_B7_AE)
        _E7_A7_AF_E5_88_86 = (_E8_AF_AF_E5_B7_AE - _E4_B8_8A_E4_B8_80_E6_AC_A1_E8_AF_AF_E5_B7_AE)
        _E8_84_89_E5_86_B2 = (KP * _E8_AF_AF_E5_B7_AE + ((KI * _E5_BE_AE_E5_88_86 + KD * _E7_A7_AF_E5_88_86)))
        mbot2.drive_speed(-2 * _E8_84_89_E5_86_B2, -2 * _E8_84_89_E5_86_B2)
        _E4_B8_8A_E4_B8_80_E6_AC_A1_E8_AF_AF_E5_B7_AE = _E8_AF_AF_E5_B7_AE

    mbot2.EM_stop("ALL")
    time.sleep(0.3)

_E5_BE_AE_E5_88_86 = 0
_E7_A7_AF_E5_88_86 = 0
_E8_AF_AF_E5_B7_AE = 0
_E4_B8_8A_E4_B8_80_E6_AC_A1_E8_AF_AF_E5_B7_AE = 0
_E8_84_89_E5_86_B2 = 0
_E6_AC_A1_E6_95_B0 = 0
_E5_88_A4_E6_96_AD = 0
_E4_BB_BB_E5_8A_A1 = 0
_E4_BB_BB_E5_8A_A1_E4_BA_8C_E8_93_9D_E8_89_B2_E6_96_B9_E5_9D_97 = 0
_E4_BD_8D_E7_BD_AE_E4_BA_8C_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97 = 0
_E4_BB_BB_E5_8A_A1_E4_B8_89_E5_A4_B9_E6_96_B9_E5_9D_97_E5_90_8E_E9_80_80_E8_B7_9D_E7_A6_BB = 0
_E6_91_87_E6_9D_86_E7_B3_BB_E6_95_B0 = 0
_E4_BD_8D_E7_BD_AE_E4_B8_80_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97 = 0
skp = 0
mmm = 0
my_1 = 0
my_2 = 0
b = 0
j = 0
k = 0
n = 0
R1 = 0
x = 0
y = 0
e = 0
spppp = 0
L = 0
D = 0
LE = 0
errrrrrrrre = 0
I_pid = 0
D_pid = 0
PID = 0
error_pid = 0
last_e_pid = 0
J = 0
sudu = 0

def pid_line(speed_pid, kp_pid, ki_pid, kd_pid):
    global error_pid, error_acc, last_e_pid, D_pid, I_pid, PID
    error_pid = mbuild.quad_rgb_sensor.get_offset_track(1)
    I_pid = (last_e_pid + mbuild.quad_rgb_sensor.get_offset_track(1))
    D_pid = (error_pid - last_e_pid)
    PID = (error_pid * kp_pid + ((I_pid * ki_pid + D_pid * kd_pid)))
    mbot2.drive_speed((speed_pid - PID), (-1*(speed_pid + PID)))
    last_e_pid = mbuild.quad_rgb_sensor.get_offset_track(1)
def B_motor_code______left_speed_N_right_speed_N_degree12_N (lspeed, rspeed, l):
    global LEFT, RIGHT, KP, KI, KD, I, D, error, last_error, pwm, g_kp, g_ki, g_kd, g_pwm, g_le, x, temt, X, Y, slope, y, z, n, red, error2, POWER2, j, speed_a, _E4_BB_BB_E5_8A_A1, _E4_BB_BB_E5_8A_A1_E4_BA_8C_E8_93_9D_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BD_8D_E7_BD_AE_E4_BA_8C_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BB_BB_E5_8A_A1_E4_B8_89_E8_88_B5_E6_9C_BA_E5_BC_A0_E5_BC_80_E7_9A_84_E8_A7_92_E5_BA_A6, _E4_BB_BB_E5_8A_A1_E4_B8_89_E5_A4_B9_E6_96_B9_E5_9D_97_E5_90_8E_E9_80_80_E8_B7_9D_E7_A6_BB, Y1, X1, my_1, my_2, _E6_91_87_E6_9D_86_E7_B3_BB_E6_95_B0, step, u, _E4_BD_8D_E7_BD_AE_E4_B8_80_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, spxxx, spxxs, g_eer, g_ii, g_dd, tong, factor_speed, skp
    mbot2.EM_reset_angle("ALL")
    cyberpi.timer.reset()
    while not (math.fabs(mbot2.EM_get_angle("EM2")) > l or math.fabs(mbot2.EM_get_angle("EM1")) > l or cyberpi.timer.get() > 3):
        mbot2.drive_speed(lspeed, -1 *rspeed)

def B_motor_code_accjia_N_N (speedssss, deg,disu):
    global sudu
    mbot2.EM_reset_angle("ALL")
    while not (math.fabs(mbot2.EM_get_angle("EM1")) > deg or math.fabs(mbot2.EM_get_angle("EM2")) > deg):
      sudu = (speedssss * math.sin(((math.fabs(mbot2.EM_get_angle("EM1")) / deg) * 90) / 180.0 * math.pi) + disu * (speedssss / math.fabs(speedssss)))
      mbot2.drive_speed(sudu, -1 * sudu)

def B_motor_code_accjian_N_N_N (speedjj, degreejj, small):
    global LEFT, RIGHT, KP, KI, KD, I, D, error, last_error, pwm, g_kp, g_ki, g_kd, g_pwm, g_le, x, temt, X, Y, slope, y, z, n, red, error2, POWER2, j, speed_a, Y1, X1, my_1, my_2, setyk, step, u, spxxx, spxxs, g_eer, g_ii, g_dd, tong, factor_speed
    mbot2.EM_reset_angle("ALL")
    cyberpi.timer.reset()
    while not (math.fabs(mbot2.EM_get_angle("EM2")) > degreejj or math.fabs(mbot2.EM_get_angle("EM1")) > degreejj or cyberpi.timer.get() > 4):
        spxxs = ((((small - speedjj)) / degreejj) * ((math.fabs(mbot2.EM_get_angle("EM1")) + 1)) + speedjj)
        mbot2.drive_speed( 1*spxxs, -1 * spxxs)
def B_motor_sensor_______left_speed_N_right_speed_N_sensor_N (sp2, sp3, s):
    global LEFT, RIGHT, KP, KI, KD, I, D, error, last_error, pwm, g_kp, g_ki, g_kd, g_pwm, g_le, x, temt, X, Y, slope, y, z, n, red, error2, POWER2, j, speed_a, _E4_BB_BB_E5_8A_A1, _E4_BB_BB_E5_8A_A1_E4_BA_8C_E8_93_9D_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BD_8D_E7_BD_AE_E4_BA_8C_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, _E4_BB_BB_E5_8A_A1_E4_B8_89_E8_88_B5_E6_9C_BA_E5_BC_A0_E5_BC_80_E7_9A_84_E8_A7_92_E5_BA_A6, _E4_BB_BB_E5_8A_A1_E4_B8_89_E5_A4_B9_E6_96_B9_E5_9D_97_E5_90_8E_E9_80_80_E8_B7_9D_E7_A6_BB, Y1, X1, my_1, my_2, _E6_91_87_E6_9D_86_E7_B3_BB_E6_95_B0, step, u, _E4_BD_8D_E7_BD_AE_E4_B8_80_E6_94_BE_E9_BB_84_E8_89_B2_E6_96_B9_E5_9D_97, spxxx, spxxs, g_eer, g_ii, g_dd, tong, factor_speed, skp
    if s == 1:
        while not (mbuild.quad_rgb_sensor.is_line("L2",1)):
            mbot2.drive_speed(1*sp2, -1 * sp3)

    else:
        if s == 2:
            while not (mbuild.quad_rgb_sensor.is_line("L1",1)):
                mbot2.drive_speed(1*sp2, -1 * sp3)

        else:
            if s == 3:
                while not (mbuild.quad_rgb_sensor.is_line("R1",1)):
                    mbot2.drive_speed(1*sp2, -1 * sp3)

            else:
                if s == 4:
                    while not (mbuild.quad_rgb_sensor.is_line("R2",1)):
                        mbot2.drive_speed(1*sp2, -1 * sp3)

                else:
                    pass
def B_motor_time____left_speed_N_right_speed_N_time_s_N (speedl, speedr, sss):
    global LEFT, RIGHT, KP, KI, KD, I, D, error, last_error, pwm, g_kp, g_ki, g_kd, g_pwm, g_le, x, temt, X, Y, slope, y, z, n, red, error2, POWER2, j, speed_a, Y1, X1, my_1, my_2, setyk, step, u, spxxx, spxxs, g_eer, g_ii, g_dd, tong, factor_speed
    cyberpi.timer.reset()
    while not cyberpi.timer.get() > sss:
        mbot2.drive_speed(1 * speedl, -1 * speedr)

    mbot2.EM_stop("ALL")
    cyberpi.audio.play_tone(700, 0.01)