// Part of ImGui Bundle - MIT License - Copyright (c) 2022-2024 Pascal Thomet - https://github.com/pthom/imgui_bundle
#include <nanobind/nanobind.h>
#include <nanobind/trampoline.h>
#include <nanobind/stl/array.h>
#include <nanobind/stl/string.h>
#include <nanobind/stl/vector.h>
#include <nanobind/stl/optional.h>
#include <nanobind/stl/function.h>
#include <nanobind/stl/shared_ptr.h>
#include <nanobind/stl/unique_ptr.h>
#include <nanobind/stl/map.h>
#include <nanobind/stl/tuple.h>
#include <nanobind/make_iterator.h>
#include <nanobind/ndarray.h>


#include "ImGuiColorTextEdit/TextEditor.h"

namespace nb = nanobind;

typedef uint8_t Char;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


void py_init_module_imgui_color_text_edit(nb::module_& m)
{
    // You can add any code here
    using PaletteIndex = TextEditor::PaletteIndex;
    using Keywords = TextEditor::Keywords;
    using Identifiers = TextEditor::Identifiers;
    using TokenRegexStrings = TextEditor::LanguageDefinition::TokenRegexStrings;

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:TextEditor.h>    ////////////////////
    auto pyClassTextEditor =
        nb::class_<TextEditor>
            (m, "TextEditor", "");

    { // inner classes & enums of TextEditor
        auto pyEnumPaletteIndex =
            nb::enum_<TextEditor::PaletteIndex>(pyClassTextEditor, "PaletteIndex", nb::is_arithmetic(), "")
                .value("default", TextEditor::PaletteIndex::Default, "")
                .value("keyword", TextEditor::PaletteIndex::Keyword, "")
                .value("number", TextEditor::PaletteIndex::Number, "")
                .value("string", TextEditor::PaletteIndex::String, "")
                .value("char_literal", TextEditor::PaletteIndex::CharLiteral, "")
                .value("punctuation", TextEditor::PaletteIndex::Punctuation, "")
                .value("preprocessor", TextEditor::PaletteIndex::Preprocessor, "")
                .value("identifier", TextEditor::PaletteIndex::Identifier, "")
                .value("known_identifier", TextEditor::PaletteIndex::KnownIdentifier, "")
                .value("preproc_identifier", TextEditor::PaletteIndex::PreprocIdentifier, "")
                .value("comment", TextEditor::PaletteIndex::Comment, "")
                .value("multi_line_comment", TextEditor::PaletteIndex::MultiLineComment, "")
                .value("background", TextEditor::PaletteIndex::Background, "")
                .value("cursor", TextEditor::PaletteIndex::Cursor, "")
                .value("selection", TextEditor::PaletteIndex::Selection, "")
                .value("error_marker", TextEditor::PaletteIndex::ErrorMarker, "")
                .value("control_character", TextEditor::PaletteIndex::ControlCharacter, "")
                .value("breakpoint", TextEditor::PaletteIndex::Breakpoint, "")
                .value("line_number", TextEditor::PaletteIndex::LineNumber, "")
                .value("current_line_fill", TextEditor::PaletteIndex::CurrentLineFill, "")
                .value("current_line_fill_inactive", TextEditor::PaletteIndex::CurrentLineFillInactive, "")
                .value("current_line_edge", TextEditor::PaletteIndex::CurrentLineEdge, "")
                .value("max", TextEditor::PaletteIndex::Max, "");
        auto pyEnumSelectionMode =
            nb::enum_<TextEditor::SelectionMode>(pyClassTextEditor, "SelectionMode", nb::is_arithmetic(), "")
                .value("normal", TextEditor::SelectionMode::Normal, "")
                .value("word", TextEditor::SelectionMode::Word, "")
                .value("line", TextEditor::SelectionMode::Line, "");
        auto pyClassTextEditor_ClassBreakpoint =
            nb::class_<TextEditor::Breakpoint>
                (pyClassTextEditor, "Breakpoint", "")
            .def_rw("m_line", &TextEditor::Breakpoint::mLine, "")
            .def_rw("m_enabled", &TextEditor::Breakpoint::mEnabled, "")
            .def_rw("m_condition", &TextEditor::Breakpoint::mCondition, "")
            .def(nb::init<>())
            ;
        auto pyClassTextEditor_ClassCoordinates =
            nb::class_<TextEditor::Coordinates>
                (pyClassTextEditor, "Coordinates", " Represents a character coordinate from the user's point of view,\n i. e. consider an uniform grid (assuming fixed-width font) on the\n screen as it is rendered, and each cell has its own coordinate, starting from 0.\n Tabs are counted as [1..mTabSize] count empty spaces, depending on\n how many space is necessary to reach the next tab stop.\n For example, coordinate (1, 5) represents the character 'B' in a line \"\tABC\", when mTabSize = 4,\n because it is rendered as \"    ABC\" on the screen.")
            .def_rw("m_line", &TextEditor::Coordinates::mLine, "")
            .def_rw("m_column", &TextEditor::Coordinates::mColumn, "")
            .def(nb::init<>())
            .def(nb::init<int, int>(),
                nb::arg("a_line"), nb::arg("a_column"))
            .def_static("invalid",
                &TextEditor::Coordinates::Invalid)
            .def("__eq__",
                &TextEditor::Coordinates::operator==, nb::arg("o"))
            .def("__ne__",
                &TextEditor::Coordinates::operator!=, nb::arg("o"))
            .def("__lt__",
                &TextEditor::Coordinates::operator<, nb::arg("o"))
            .def("__gt__",
                &TextEditor::Coordinates::operator>, nb::arg("o"))
            .def("__le__",
                &TextEditor::Coordinates::operator<=, nb::arg("o"))
            .def("__ge__",
                &TextEditor::Coordinates::operator>=, nb::arg("o"))
            .def("__sub__",
                &TextEditor::Coordinates::operator-, nb::arg("o"))
            ;
        auto pyClassTextEditor_ClassIdentifier =
            nb::class_<TextEditor::Identifier>
                (pyClassTextEditor, "Identifier", "")
            .def("__init__", [](TextEditor::Identifier * self, const std::optional<const TextEditor::Coordinates> & mLocation = std::nullopt, std::string mDeclaration = std::string())
            {
                new (self) TextEditor::Identifier();  // placement new
                auto r = self;
                if (mLocation.has_value())
                    r->mLocation = mLocation.value();
                else
                    r->mLocation = TextEditor::Coordinates();
                r->mDeclaration = mDeclaration;
            },
            nb::arg("m_location") = nb::none(), nb::arg("m_declaration") = std::string()
            )
            .def_rw("m_location", &TextEditor::Identifier::mLocation, "")
            .def_rw("m_declaration", &TextEditor::Identifier::mDeclaration, "")
            ;
        auto pyClassTextEditor_ClassGlyph =
            nb::class_<TextEditor::Glyph>
                (pyClassTextEditor, "Glyph", "")
            .def_rw("m_char", &TextEditor::Glyph::mChar, "")
            .def_rw("m_color_index", &TextEditor::Glyph::mColorIndex, "")
            .def(nb::init<Char, TextEditor::PaletteIndex>(),
                nb::arg("a_char"), nb::arg("a_color_index"))
            ;
        auto pyClassTextEditor_ClassLanguageDefinition =
            nb::class_<TextEditor::LanguageDefinition>
                (pyClassTextEditor, "LanguageDefinition", "")
            .def_rw("m_name", &TextEditor::LanguageDefinition::mName, "")
            .def_rw("m_keywords", &TextEditor::LanguageDefinition::mKeywords, "")
            .def_rw("m_identifiers", &TextEditor::LanguageDefinition::mIdentifiers, "")
            .def_rw("m_preproc_identifiers", &TextEditor::LanguageDefinition::mPreprocIdentifiers, "")
            .def_rw("m_comment_start", &TextEditor::LanguageDefinition::mCommentStart, "")
            .def_rw("m_comment_end", &TextEditor::LanguageDefinition::mCommentEnd, "")
            .def_rw("m_single_line_comment", &TextEditor::LanguageDefinition::mSingleLineComment, "")
            .def_rw("m_auto_indentation", &TextEditor::LanguageDefinition::mAutoIndentation, "")
            .def_rw("m_token_regex_strings", &TextEditor::LanguageDefinition::mTokenRegexStrings, "")
            .def_rw("m_case_sensitive", &TextEditor::LanguageDefinition::mCaseSensitive, "")
            .def(nb::init<>())
            .def_static("c_plus_plus",
                &TextEditor::LanguageDefinition::CPlusPlus, nb::rv_policy::reference)
            .def_static("hlsl",
                &TextEditor::LanguageDefinition::HLSL, nb::rv_policy::reference)
            .def_static("glsl",
                &TextEditor::LanguageDefinition::GLSL, nb::rv_policy::reference)
            .def_static("python",
                &TextEditor::LanguageDefinition::Python, nb::rv_policy::reference)
            .def_static("c",
                &TextEditor::LanguageDefinition::C, nb::rv_policy::reference)
            .def_static("sql",
                &TextEditor::LanguageDefinition::SQL, nb::rv_policy::reference)
            .def_static("angel_script",
                &TextEditor::LanguageDefinition::AngelScript, nb::rv_policy::reference)
            .def_static("lua",
                &TextEditor::LanguageDefinition::Lua, nb::rv_policy::reference)
            .def_static("c_sharp",
                &TextEditor::LanguageDefinition::CSharp, nb::rv_policy::reference)
            .def_static("json",
                &TextEditor::LanguageDefinition::Json, nb::rv_policy::reference)
            ;
        auto pyEnumUndoOperationType =
            nb::enum_<TextEditor::UndoOperationType>(pyClassTextEditor, "UndoOperationType", nb::is_arithmetic(), "")
                .value("add", TextEditor::UndoOperationType::Add, "")
                .value("delete", TextEditor::UndoOperationType::Delete, "");
        auto pyClassTextEditor_ClassUndoOperation =
            nb::class_<TextEditor::UndoOperation>
                (pyClassTextEditor, "UndoOperation", "")
            .def("__init__", [](TextEditor::UndoOperation * self, std::string mText = std::string(), const std::optional<const TextEditor::Coordinates> & mStart = std::nullopt, const std::optional<const TextEditor::Coordinates> & mEnd = std::nullopt, TextEditor::UndoOperationType mType = TextEditor::UndoOperationType())
            {
                new (self) TextEditor::UndoOperation();  // placement new
                auto r = self;
                r->mText = mText;
                if (mStart.has_value())
                    r->mStart = mStart.value();
                else
                    r->mStart = TextEditor::Coordinates();
                if (mEnd.has_value())
                    r->mEnd = mEnd.value();
                else
                    r->mEnd = TextEditor::Coordinates();
                r->mType = mType;
            },
            nb::arg("m_text") = std::string(), nb::arg("m_start") = nb::none(), nb::arg("m_end") = nb::none(), nb::arg("m_type") = TextEditor::UndoOperationType()
            )
            .def_rw("m_text", &TextEditor::UndoOperation::mText, "")
            .def_rw("m_start", &TextEditor::UndoOperation::mStart, "")
            .def_rw("m_end", &TextEditor::UndoOperation::mEnd, "")
            .def_rw("m_type", &TextEditor::UndoOperation::mType, "")
            ;
    } // end of inner classes & enums of TextEditor

    pyClassTextEditor
        .def(nb::init<>())
        .def("set_language_definition",
            &TextEditor::SetLanguageDefinition, nb::arg("a_language_def"))
        .def("get_language_definition_name",
            &TextEditor::GetLanguageDefinitionName)
        .def("get_palette",
            &TextEditor::GetPalette, nb::rv_policy::reference)
        .def("set_palette",
            &TextEditor::SetPalette, nb::arg("a_value"))
        .def("set_error_markers",
            &TextEditor::SetErrorMarkers, nb::arg("a_markers"))
        .def("set_breakpoints",
            &TextEditor::SetBreakpoints, nb::arg("a_markers"))
        .def("render",
            [](TextEditor & self, const char * aTitle, bool aParentIsFocused = false, const std::optional<const ImVec2> & aSize = std::nullopt, bool aBorder = false) -> bool
            {
                auto Render_adapt_mutable_param_with_default_value = [&self](const char * aTitle, bool aParentIsFocused = false, const std::optional<const ImVec2> & aSize = std::nullopt, bool aBorder = false) -> bool
                {

                    const ImVec2& aSize_or_default = [&]() -> const ImVec2 {
                        if (aSize.has_value())
                            return aSize.value();
                        else
                            return ImVec2();
                    }();

                    auto lambda_result = self.Render(aTitle, aParentIsFocused, aSize_or_default, aBorder);
                    return lambda_result;
                };

                return Render_adapt_mutable_param_with_default_value(aTitle, aParentIsFocused, aSize, aBorder);
            },
            nb::arg("a_title"), nb::arg("a_parent_is_focused") = false, nb::arg("a_size") = nb::none(), nb::arg("a_border") = false,
            "---\nPython bindings defaults:\n    If aSize is None, then its default value will be: ImVec2()")
        .def("set_text",
            &TextEditor::SetText, nb::arg("a_text"))
        .def("get_text",
            [](TextEditor & self) { return self.GetText(); })
        .def("set_text_lines",
            &TextEditor::SetTextLines, nb::arg("a_lines"))
        .def("get_text_lines",
            &TextEditor::GetTextLines)
        .def("get_clipboard_text",
            &TextEditor::GetClipboardText)
        .def("get_selected_text",
            &TextEditor::GetSelectedText, nb::arg("a_cursor") = -1)
        .def("get_current_line_text",
            &TextEditor::GetCurrentLineText)
        .def("get_total_lines",
            &TextEditor::GetTotalLines)
        .def("is_overwrite",
            &TextEditor::IsOverwrite)
        .def("set_read_only",
            &TextEditor::SetReadOnly, nb::arg("a_value"))
        .def("is_read_only",
            &TextEditor::IsReadOnly)
        .def("is_text_changed",
            &TextEditor::IsTextChanged)
        .def("on_cursor_position_changed",
            &TextEditor::OnCursorPositionChanged, nb::arg("a_cursor"))
        .def("is_colorizer_enabled",
            &TextEditor::IsColorizerEnabled)
        .def("set_colorizer_enable",
            &TextEditor::SetColorizerEnable, nb::arg("a_value"))
        .def("get_cursor_position",
            &TextEditor::GetCursorPosition)
        .def("set_cursor_position",
            nb::overload_cast<const TextEditor::Coordinates &, int>(&TextEditor::SetCursorPosition), nb::arg("a_position"), nb::arg("a_cursor") = -1)
        .def("set_cursor_position",
            nb::overload_cast<int, int, int>(&TextEditor::SetCursorPosition), nb::arg("a_line"), nb::arg("a_char_index"), nb::arg("a_cursor") = -1)
        .def("on_line_deleted",
            &TextEditor::OnLineDeleted, nb::arg("a_line_index"), nb::arg("a_handled_cursors") = nb::none())
        .def("on_lines_deleted",
            &TextEditor::OnLinesDeleted, nb::arg("a_first_line_index"), nb::arg("a_last_line_index"))
        .def("on_line_added",
            &TextEditor::OnLineAdded, nb::arg("a_line_index"))
        .def("set_handle_mouse_inputs",
            &TextEditor::SetHandleMouseInputs, nb::arg("a_value"))
        .def("is_handle_mouse_inputs_enabled",
            &TextEditor::IsHandleMouseInputsEnabled)
        .def("set_handle_keyboard_inputs",
            &TextEditor::SetHandleKeyboardInputs, nb::arg("a_value"))
        .def("is_handle_keyboard_inputs_enabled",
            &TextEditor::IsHandleKeyboardInputsEnabled)
        .def("set_im_gui_child_ignored",
            &TextEditor::SetImGuiChildIgnored, nb::arg("a_value"))
        .def("is_im_gui_child_ignored",
            &TextEditor::IsImGuiChildIgnored)
        .def("set_show_whitespaces",
            &TextEditor::SetShowWhitespaces, nb::arg("a_value"))
        .def("is_showing_whitespaces",
            &TextEditor::IsShowingWhitespaces)
        .def("set_show_short_tab_glyphs",
            &TextEditor::SetShowShortTabGlyphs, nb::arg("a_value"))
        .def("is_showing_short_tab_glyphs",
            &TextEditor::IsShowingShortTabGlyphs)
        .def("u32_color_to_vec4",
            &TextEditor::U32ColorToVec4, nb::arg("in_"))
        .def("set_tab_size",
            &TextEditor::SetTabSize, nb::arg("a_value"))
        .def("get_tab_size",
            &TextEditor::GetTabSize)
        .def("insert_text",
            nb::overload_cast<const std::string &, int>(&TextEditor::InsertText), nb::arg("a_value"), nb::arg("a_cursor") = -1)
        .def("insert_text",
            nb::overload_cast<const char *, int>(&TextEditor::InsertText), nb::arg("a_value"), nb::arg("a_cursor") = -1)
        .def("move_up",
            &TextEditor::MoveUp, nb::arg("a_amount") = 1, nb::arg("a_select") = false)
        .def("move_down",
            &TextEditor::MoveDown, nb::arg("a_amount") = 1, nb::arg("a_select") = false)
        .def("move_left",
            &TextEditor::MoveLeft, nb::arg("a_amount") = 1, nb::arg("a_select") = false, nb::arg("a_word_mode") = false)
        .def("move_right",
            &TextEditor::MoveRight, nb::arg("a_amount") = 1, nb::arg("a_select") = false, nb::arg("a_word_mode") = false)
        .def("move_top",
            &TextEditor::MoveTop, nb::arg("a_select") = false)
        .def("move_bottom",
            &TextEditor::MoveBottom, nb::arg("a_select") = false)
        .def("move_home",
            &TextEditor::MoveHome, nb::arg("a_select") = false)
        .def("move_end",
            &TextEditor::MoveEnd, nb::arg("a_select") = false)
        .def("set_selection_start",
            &TextEditor::SetSelectionStart, nb::arg("a_position"), nb::arg("a_cursor") = -1)
        .def("set_selection_end",
            &TextEditor::SetSelectionEnd, nb::arg("a_position"), nb::arg("a_cursor") = -1)
        .def("get_selection_start",
            &TextEditor::GetSelectionStart, nb::arg("a_cursor") = -1)
        .def("get_selection_end",
            &TextEditor::GetSelectionEnd, nb::arg("a_cursor") = -1)
        .def("set_selection",
            nb::overload_cast<const TextEditor::Coordinates &, const TextEditor::Coordinates &, TextEditor::SelectionMode, int, bool>(&TextEditor::SetSelection), nb::arg("a_start"), nb::arg("a_end"), nb::arg("a_mode") = TextEditor::SelectionMode::Normal, nb::arg("a_cursor") = -1, nb::arg("is_spawning_new_cursor") = false)
        .def("set_selection",
            nb::overload_cast<int, int, int, int, TextEditor::SelectionMode, int, bool>(&TextEditor::SetSelection), nb::arg("a_start_line"), nb::arg("a_start_char_index"), nb::arg("a_end_line"), nb::arg("a_end_char_index"), nb::arg("a_mode") = TextEditor::SelectionMode::Normal, nb::arg("a_cursor") = -1, nb::arg("is_spawning_new_cursor") = false)
        .def("select_word_under_cursor",
            &TextEditor::SelectWordUnderCursor)
        .def("select_all",
            &TextEditor::SelectAll)
        .def("has_selection",
            &TextEditor::HasSelection)
        .def("copy",
            &TextEditor::Copy)
        .def("cut",
            &TextEditor::Cut)
        .def("paste",
            &TextEditor::Paste)
        .def("delete",
            &TextEditor::Delete, nb::arg("a_word_mode") = false)
        .def("get_undo_index",
            &TextEditor::GetUndoIndex)
        .def("can_undo",
            &TextEditor::CanUndo)
        .def("can_redo",
            &TextEditor::CanRedo)
        .def("undo",
            &TextEditor::Undo, nb::arg("a_steps") = 1)
        .def("redo",
            &TextEditor::Redo, nb::arg("a_steps") = 1)
        .def("clear_extra_cursors",
            &TextEditor::ClearExtraCursors)
        .def("clear_selections",
            &TextEditor::ClearSelections)
        .def("select_next_occurrence_of",
            &TextEditor::SelectNextOccurrenceOf, nb::arg("a_text"), nb::arg("a_text_size"), nb::arg("a_cursor") = -1)
        .def("add_cursor_for_next_occurrence",
            &TextEditor::AddCursorForNextOccurrence)
        .def_static("get_mariana_palette",
            &TextEditor::GetMarianaPalette, nb::rv_policy::reference)
        .def_static("get_dark_palette",
            &TextEditor::GetDarkPalette, nb::rv_policy::reference)
        .def_static("get_light_palette",
            &TextEditor::GetLightPalette, nb::rv_policy::reference)
        .def_static("get_retro_blue_palette",
            &TextEditor::GetRetroBluePalette, nb::rv_policy::reference)
        .def_static("is_glyph_word_char",
            &TextEditor::IsGlyphWordChar, nb::arg("a_glyph"))
        .def("im_gui_debug_panel",
            &TextEditor::ImGuiDebugPanel, nb::arg("panel_name") = "Debug")
        .def("unit_tests",
            &TextEditor::UnitTests)
        ;
    ////////////////////    </generated_from:TextEditor.h>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
