import subprocess
import re
#import time
import os
import sys
#import stat
import zipfile
import shutil
import shlex
#import platform
import getpass
#import datetime
import traceback
#import random
#import yaml
from pathlib import Path
from threading import Thread
#from xmlrpc.server import SimpleXMLRPCServer
#from simplepam import authenticate
from .utils.utilities import Substitute

class Task(Thread):
    """
    Individual TaskServer Task object (runs in its own thread)
    """
    def __init__ (self,cmd, taskid=None, task_vars=None):
        Thread.__init__(self)
        self.cmd = cmd
        self.taskid = taskid
        self.done = False
        self.output = []
        self.exitCode = None
        self.task = None
        script = cmd.split()[0]
        task_vars['FM_SCRIPT'] = os.path.splitext(script)[0]
        task_vars['FM_USER'] = getpass.getuser() # can
        if not taskid: 
            task_vars['FM_TASKID'] = 0
        else:
            task_vars['FM_TASKID'] = taskid
        if 'FM_TASK_DATA' not in task_vars:
            task_vars['FM_TASK_DATA'] = os.path.join(task_vars['FM_LOGROOT'], 'task_data')  # also in common.sh and flexmin service code
        if 'FM_PARAMS' not in task_vars:
            taskfolder = 'task' + str(task_vars['FM_TASKID'])
            task_vars['FM_PARAMS'] = os.path.join(task_vars['FM_TASK_DATA'],taskfolder)  # calculated separately for batch tasks
        if 'FM_SCRIPT_PARAM' not in task_vars:
            if 'FM_SCRIPT' in task_vars:
                paramfile = os.path.splitext(task_vars['FM_SCRIPT'])[0] + "_param"
                task_vars['FM_SCRIPT_PARAM'] = os.path.join(task_vars['FM_PARAMS'],paramfile)
        # Check if log file exists for this task
        task_vars['FM_TASK_LOG'] = os.path.join(task_vars['FM_LOGROOT'],os.path.splitext(script)[0] + '.log')
        self.task_vars = task_vars  # passed from task initialisation


    def completed(self):
        return self.done


    def lineCount(self):
        return len(self.output)
        

    def stateClear(self, x):
        """
        Removes the first x number of lines from the task state. If x exceeds the
        length of the current state, the state will be cleared completely.
        """
        self.output = self.output[x:]


    def state(self):
        """
        Returns a list of output lines that have been generated by the task
        so far. The newline chars are stripped (from right) so lines can be
        displayed appropriately by the client application.
        """
        return self.output


    def stateUpdate(self,line,titleTag=''):
        """
        Return task output from the specified line onwards, and the current
        length of the output retrieved so far.
        Client uses the returned lines value to keep track of what output it
        has received already it only gets updated data, not all data.
        """
        # get output and then calculate length (number of lines)
        output = '\n'.join(self.output) + "\n---" # convert to single text string
        titleClose = re.sub(r'^<','</',titleTag)
        adjusted = output
        
        # mark out first title --- block to exclude from output
        adjusted = re.sub(r'^title:','xtitle:', adjusted, 1)
        adjusted = re.sub(r'^---','x---', adjusted, 1)

        # handle title --- blocks, removing contents and just leaving title
        adjusted = re.sub(r'^title: ([^\n]*)$.*?^[-\.]{3}$', r'%s\1%s' % (titleTag, titleClose), adjusted, 0, re.MULTILINE|re.DOTALL)
        adjusted = re.sub(r'\n[-]{3}$','',adjusted) # take off last --- if not used
        
        # normalise first title --- block again
        adjusted = re.sub(r'^xtitle:','title:', adjusted, 1)
        adjusted = re.sub(r'^x---','---', adjusted, 1)

        adjusted = adjusted.split('\n') # convert back to list of lines
        # this is so the line count is consistent with returned output
        lines = len(adjusted)
        return adjusted[line:], lines
        

    def run(self):
        """
        Begin the task, redirects stderr to stdout and runs in a shell
        environment.

        If task 'command' is in fact a zip file, then the zip file gets
        extracted into the task folder and task.cmd or task.sh are run.
        """
        self.alive = True
        folder = None
        taskFolder = None
        file = None
        display = False
        debug = False
        if 'FMS_PARAMETER' in self.task_vars:
            if self.task_vars['FMS_PARAMETER'] == 'display':
                display = True
            elif self.task_vars['FMS_PARAMETER'] == 'debug':
                debug = True

        param_sub = Substitute('\{\{([\w\-\_@]+)\}\}')

        # TODO Set a working folder path for any task working files
        folder, file = os.path.split(self.cmd)

        """
        if "flexmin_batch" in self.cmd:
            # make a folder for this package, checks no exist folder
            done = False
            num = 0
            while not done:
                taskFolder = os.path.join(self.task_vars['FM_TASK_TMP'],"package"+str(num))
                try:
                    # create folder (will fail if folder already exists
                    os.makedirs(taskFolder)
                    done = True
                except:
                    num = num + 1
                    if num > 10:
                        # abandon attempt to create package folder after number 10
                        # prevents infinite loop
                        if display or debug:
                            print("Can't create package folder, folders already exist")
                        return
            
        else:
        """
        # make a folder just for this task (keeps things neat)
        taskFolder = os.path.join(self.task_vars['FM_TASK_TMP'],"task"+str(self.taskid))
        try:
            os.makedirs(taskFolder)
        except:
            if display or debug:
                print("Could not create task folder " + taskFolder)
            return
            
        if display or debug:
            print("Taskfolder: " + taskFolder)

        # get parameter list of the command
        plist = shlex.split(self.cmd)
        
        # Just the one command supplied by original parameters
        tasks = [{'id': self.task_vars['FM_TASKID'],
                    'cmd': self.cmd}]
        manyTasks = False
            
        # Execute all tasks listed in the tasks list.
        for t in tasks:
            task_vars = self.task_vars
            cmd = t['cmd']
            if debug: print("Command:", cmd)
            cmdvars = shlex.split(cmd)
            if display and 'comment' in t and t['comment']:
                print("#" + t['comment'])
            if 'comment' in t:
                self.output.append("# " + t['comment'])
                
            '''
            if manyTasks:
                # adjust FM_PARAMS and FM_SCRIPT_PARAM to point to extract task folder
                task_vars['FM_PARAMS'] = os.path.join(taskFolder,'task' + str(t['id']))
                task_vars['FM_TASKID'] = str(t['id'])
                paramfile = re.sub('\.(sh|py)$','',cmdvars[0]) + '_param'
                task_vars['FM_SCRIPT_PARAM'] = os.path.join(task_vars['FM_PARAMS'],paramfile)
            '''
                
            # Begin task
            if cmdvars[0][-3:].lower() == ".py":
                shellCmd = False
                script = cmdvars[0][0:-3]

                """
                Add FM_SCRIPTS parent path to python system path to allow 
                import of module for execution. Goes to parent and imports 
                scripts.xyz to reduce chances of importing identical named 
                modules from elsewhere.
                """
                script_path = Path(task_vars['FM_SCRIPTS'])
                sys.path.append(str(script_path.parent))
                #print("sys.path: " + str(sys.path))
                
                mod = "scripts." + script
                try:
                    if debug: print("Importing", mod)
                    # import module using dot notation to refer to the scripts folder
                    # this ensures only modules from with the scripts folder are
                    # used, preventing the hijacking of this service with
                    # unauthorized scripts from elsewhere on the system.
                    task_module = __import__(mod)
                except Exception as e:
                    task_module = None
                    if debug: 
                        print("Import failed")
                        print(e)
                    self.output.append("error: Flexmin service had problem importing module '" + mod + "' (python script)")

                sys.path.pop()  # remove newly add path from sys.path

                if task_module:
                    # run module function (run) provide output list for 
                    # function to update
                    try:
                        if debug: print("Executing run method")
                        task_script = getattr(task_module,script)
                        task_script.run(cmdvars[1:],task_vars,self.output)
                    except:
                        self.output.append(traceback.format_exc())
            else:
                shellCmd = True
                # needed for batch tasks (not needed in common.sh)
                fm_shell_pre = task_vars['FM_SCRIPTS'] + os.sep + 'common.sh' + " " + str(task_vars['FM_TASKID']) + " ./"
                
                if debug: print("Shell pre: " + fm_shell_pre)
                
                # Clean up cmd to ensure no / or ../ or ./ 
                # Prevents directory traversal attacks, ensures only scripts
                # from ./scripts/ folder are executed
                cmd = re.sub(r'(^[^\s]*\/|^[^\s]*\.\.|^[^\s]*\/\.\/)','',cmd)
                
                cmd = fm_shell_pre + cmd  # add shell comand prefix here
                
                if debug: print("Full cmd: " + cmd)
                
                self.task = subprocess.Popen(cmd,
                                             shell=True,
                                             stdout=subprocess.PIPE,
                                             stderr=subprocess.STDOUT,
                                             )
    
            if debug: print("Command output:")
                
            # Keep adding stout lines to self.output while task is running
            while shellCmd:
                response = self.task.stdout.readline().decode()  # decode to convert from bytestring to strings
                if response:
                    if response.strip() == "flexmin-force-exit":
                        shellCmd = False
                        self.exitCode = 0
                        self.task.kill()
                        break
                    else:
                        self.output.append(response.rstrip())
                else:
                    break
            
            if debug:
                print(self.output)
                
            # Confirm task finished, and get exit code
            if shellCmd:
                self.exitCode = self.task.wait()
            else:
                self.exitCode = 0
                
            if debug: print("Command exit code: " +str(self.exitCode))

        # Remove task folder and any contents
        if taskFolder:
            #pass
            shutil.rmtree(taskFolder)

        # Mark task as done for purpose of .completed method.
        if manyTasks:
            print("Package completed")
            print(str(param_sub))
        self.done = True
 
