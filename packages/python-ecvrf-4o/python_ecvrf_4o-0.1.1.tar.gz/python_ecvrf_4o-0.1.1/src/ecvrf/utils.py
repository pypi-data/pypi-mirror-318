# File: src/ecvrf/utils.py

from ecdsa import ellipticcurve  # Added import
from ecdsa import SECP256k1  # Ensure SECP256k1 is imported if used

def bytes_to_int(b: bytes) -> int:
    """
    Converts a byte sequence to an integer using big-endian byte order.

    Args:
        b (bytes): The byte sequence to convert.

    Returns:
        int: The resulting integer.
    """
    return int.from_bytes(b, byteorder='big')

def int_to_bytes(i: int, length: int = 32) -> bytes:
    """
    Converts an integer to a byte sequence using big-endian byte order.

    Args:
        i (int): The integer to convert.
        length (int, optional): The desired byte length of the output. Defaults to 32.

    Returns:
        bytes: The resulting byte sequence.

    Raises:
        ValueError: If the integer cannot be represented within the specified byte length.
    """
    try:
        return i.to_bytes(length, byteorder='big')
    except OverflowError as e:
        raise ValueError(f"Integer too large to convert to {length} bytes.") from e

def validate_input(data: bytes, name: str = "Input") -> None:
    """
    Validates that the input data is of type bytes and not empty.

    Args:
        data (bytes): The data to validate.
        name (str, optional): The name of the input for error messages. Defaults to "Input".

    Raises:
        TypeError: If data is not bytes.
        ValueError: If data is empty.
    """
    if not isinstance(data, bytes):
        raise TypeError(f"{name} must be of type 'bytes'.")
    if not data:
        raise ValueError(f"{name} cannot be empty.")

def generate_secure_random_bytes(length: int = 32) -> bytes:
    """
    Generates a secure random byte sequence of the specified length.

    Args:
        length (int, optional): The length of the byte sequence. Defaults to 32.

    Returns:
        bytes: The generated byte sequence.
    """
    import os
    return os.urandom(length)

def encode_point(point: ellipticcurve.Point) -> bytes:
    """
    Encodes an elliptic curve point into bytes (uncompressed format).

    Args:
        point (ellipticcurve.Point): The point to encode.

    Returns:
        bytes: The encoded point.
    """
    x_bytes = int_to_bytes(point.x(), 32)
    y_bytes = int_to_bytes(point.y(), 32)
    return b'\x04' + x_bytes + y_bytes  # Uncompressed format indicator

def decode_point(data: bytes, curve: SECP256k1) -> ellipticcurve.Point:
    """
    Decodes bytes into an elliptic curve point.

    Args:
        data (bytes): The encoded point in uncompressed format.
        curve (SECP256k1): The elliptic curve to which the point belongs.

    Returns:
        ellipticcurve.Point: The decoded point.

    Raises:
        ValueError: If the encoding is invalid or the point does not lie on the curve.
    """
    if len(data) != 65 or data[0] != 0x04:
        raise ValueError("Invalid point encoding. Expected uncompressed format with 65 bytes.")

    x = bytes_to_int(data[1:33])
    y = bytes_to_int(data[33:65])
    if not curve.curve.contains_point(x, y):
        raise ValueError("Decoded point is not on the curve.")
    return ellipticcurve.Point(curve.curve, x, y)
